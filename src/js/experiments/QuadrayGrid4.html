<!DOCTYPE html><head><meta charset="UTF-8"><title>QuadCraft</title></head>
<body style="margin: 0; overflow: hidden; background: #111;">
<center style="color:white">
	<br>
	<font color=#00cc00>
		<b>MOVE LEFT/RIGHT/UP/DOWN:</b> gamepad left joystick <b>OR</b> drag mouse left button <b>OR</b> 4 arrow keys<br>
		<b>MOVE FORWARD/BACKWARD:</b> gamepad 2 analog triggers <b>OR</b> drag both mouse buttons at once <b>OR</b> Control/Insert beside arrow keys.<br>
		<b>TURN:</b> gamepad right joystick <b>OR</b> drag mouse right button.<br>
		<b>UNPAINT/PAINT</b> (with current paintbrush): LB/RB on gamepad <b>OR</b> `/1 on keyboard<br>
	</font>
	<table border=2><tr><td valign="top">
		Paintbrush shape<br>(TODO multi select):<br>
		<select id="paintbrushSelect"
				size="12"			<!-- 8 items → no scrollbar -->
				style="min-width: 170px">
			<!-- options filled by JS -->
		</select>
	</td><td>
	<input type=button value="Example code A" onclick="dom('textBoxToEval').value = 'fillGridByFunc(selq, 5, q=>{\n	return q.toCartesian()[0]==0;\n});';">
	<input type=button value="B" onclick="dom('textBoxToEval').value = 'fillGridByFunc(selq, 8, q=>{\n	return q.toCartesian()[0]>1.5;\n});';">
	<input type=button value="C" onclick="dom('textBoxToEval').value = 'AddColoredDots(gridDotsNear(selq,5),\'green\');';">
	<input type=button value="D" onclick="dom('textBoxToEval').value = 'fillGridByFunc(selq, 5, q=>{\n	return Math.random()<.3;\n});';">
	<input type=button value="E" onclick="dom('textBoxToEval').value = 'fillGridByFunc(selq, 14, q=>{\n	let xyz = q.toCartesian();\n	let x = xyz[0], y = xyz[1], z = xyz[2];\n	let xyDist = Math.hypot(x*x,y*y);\n	let yzDist = Math.hypot(y*y,z*z);\n	let xzDist = Math.hypot(x*x,z*z);\n	let xyzDist = Math.hypot(x*x,y*y,z*z);\n	return xyzDist<12 && xyDist>3 && yzDist>3 && xzDist>3;\n});';">
	<input type=button value="X" title="empty text box" onclick="dom('textBoxToEval').value = '';">
	<br>
<textarea id=textBoxToEval rows=10 cols=40>
fillGridByFunc(selq, 5, q=>{
	return q.toCartesian()[0]==0
});
/*fillGridByFunc(selq, 8, q=>{
	return q.toCartesian()[0]<0
});*/
/*AddColoredDots(gridDotsNear(selq,5),'green');
*/
/*fillGridByFunc(selq, 5, q=>{
	return Math.random()<.3;
});*/
</textarea><br>
		<input type=button onclick="let jsCode = dom('textBoxToEval').value; console.log('evalling: '+jsCode); let ret = eval(jsCode); console.log('Returned: '+ret);" value="eval text box (see errors on browser console)"></input>
	</td><td>
		<div id=saveLoadDiv>
			<input type=button value="Delete QuickSaves" onclick="deleteCookies();" title="delete cookies, including those saved by Quicksave (cookie) 1 to 9.">
			<input type=button value="QuickSave (cookie) 1" onclick="quicksave('1');">
			<input type=button value="2" onclick="quicksave('2');">
			<input type=button value="3" onclick="quicksave('3');">
			<input type=button value="4" onclick="quicksave('4');">
			<input type=button value="5" onclick="quicksave('5');">
			<input type=button value="6" onclick="quicksave('6');">
			<input type=button value="7" onclick="quicksave('7');">
			<input type=button value="8" onclick="quicksave('8');">
			<input type=button value="9" onclick="quicksave('9');">
			<input type=button value="Save (file) " onclick="console.log('save file clicked'); let filename = prompt('Filename?','quadcraft_quadgrid4_'+time()+'.json'); if(filename) saveFile(filename, 'application/json', StateJson());">
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			<input type=button value="QuickLoad (cookie) 1" onclick="quickload('1');">
			<input type=button value="2" onclick="quickload('2');">
			<input type=button value="3" onclick="quickload('3');">
			<input type=button value="4" onclick="quickload('4');">
			<input type=button value="5" onclick="quickload('5');">
			<input type=button value="6" onclick="quickload('6');">
			<input type=button value="7" onclick="quickload('7');">
			<input type=button value="8" onclick="quickload('8');">
			<input type=button value="9" onclick="quickload('9');">
			<input id=openFileInput type=file value="Open (file)" onchange="openFileInputClicked(event);">
			
		</div>
		<input type=button onclick="SimKeyPress('Shift');" value="Shift (toggle grid dots)">
		<input type=button onclick="SimKeyPresses('a a a a d d d d q q q q e eee');" value="example octahedrons and tetrahedrons">
		<input type=button value="ClearShapes" onclick="ClearShapes();"></input>
		<br>
		<input type="checkbox" id="chkQuaternionCamera" checked><label for="chkQuaternionCamera" title="2025-7-28+ upgrading the camera code to use camPos and camQ instead of zoom, angleX, etc. This should fix the distortion of 3d positions at some angles and positions and allow you to fly through it with a gamepad with 2 analog triggers and 2 analog joysticks, or mouse.">quaternion camera (gamepad or mouse)</label>
		<input type="checkbox" id="isConePlaneIntersection" checked><label for="isConePlaneIntersection" title="use this graphics mode to paint an oval instead of circle so the balls touch eachother on screen if they're touching in 3d.">isConePlaneIntersection</label>
		<input type="checkbox" id="isCcpBallGrid" checked><label for="isCcpBallGrid" title="CCPBallGrid class is an optimization to store a volume of CCP aligned balls as CCPBallRange objects so costs 2d surface instead of 3d volume.">isCcpBallGrid</label>
		<br>
		<input type=button onclick="SimKeyPress('z');" value="'z' (tog tetrahedron Z)">
		<input type=button onclick="SimKeyPress('x');" value="'x' (tog octahedron)">
		<input type=button onclick="SimKeyPress('c');" value="'c' (tog tetrahedron X)">
		<input type=button onclick="SimKeyPress(' ');" value="' ' space (all 3)">
		&nbsp;&nbsp;&nbsp;
		<input type=button onclick="addDirectionsBalls();" value="add Directions balls">
		<br>
		offsetX, offsetY, zoom, angleX, and angleY are only relevant in the old way, NOT quaternion camera (unchecked).<br>
		<nobr>offsetX=<input type=number step=10 id=numOffsetX oninput="copyUiControlsToWorldState();" style="width: 60px;"></input></nobr>
		<nobr>offsetY=<input type=number step=10 id=numOffsetY oninput="copyUiControlsToWorldState();" style="width: 60px;"></input></nobr>
		<nobr>zoom=<input type=number step=.04 id=numZoom oninput="copyUiControlsToWorldState();" style="width: 60px;"></input></nobr>
		<nobr>angleX=<input type=number step=.05 id=numAngleX oninput="copyUiControlsToWorldState();" style="width: 60px;"></input></nobr>
		<nobr>angleY=<input type=number step=.05 id=numAngleY oninput="copyUiControlsToWorldState();" style="width: 60px;"></input></nobr>
		<label id=labelUnderUiControls>...</label>
		<table id=uiControls><tr><td>
			<nobr>
				<input type=button onclick="SimKeyPress('q');" value="q">
				<input type=button onclick="SimKeyPress('w');" value="w">
				<input type=button onclick="SimKeyPress('e');" value="e">
				<input type=button onclick="SimKeyPress('r');" value="r">
				<input type=button onclick="SimKeyPress('t');" value="t">
				<input type=button onclick="SimKeyPress('y');" value="y">
			</nobr>
		</td><td>
			6 backward directions (can push these on keyboard)
		</td></tr><tr><td>
			<nobr>
				<input type=button onclick="SimKeyPress('a');" value="a">
				<input type=button onclick="SimKeyPress('s');" value="s">
				<input type=button onclick="SimKeyPress('d');" value="d">
				<input type=button onclick="SimKeyPress('f');" value="f">
				<input type=button onclick="SimKeyPress('g');" value="g">
				<input type=button onclick="SimKeyPress('h');" value="h">
			</nobr>
		</td><td>
			6 forward directions (or keyboard)<br>
			<input type="checkbox" id="directionsButtonsMoveCam" checked><label for="directionsButtonsMoveCam">directionsButtonsMoveCam </label>
		</td><td>
			<label id=camQuadLabel></label>
		</td></tr></table>
	</td></tr></table>
	
	<canvas id="canvas" style="display: block; width: 100vw; height: 100vh; cursor: grab"></canvas>
</center>
<script>

var Err = str=>{
	throw new Error(str);
};

const ROOT2 = Math.SQRT2;
const SCALE = 2/ROOT2; //multiply quadrays by this to always be on 3d integer grid after .toCartesian()
const S3 = Math.sqrt(9 / 8);

var Buttons = {}; //keyboard button string to 1 if down, deleted or 0 if not.

var randInt = max=>(randFlo(max)|0);

var randFlo = max=>(Math.random()*max);

var randXYZ = ()=>[randFlo(side),randFlo(side),randFlo(side)];

var displayCameraCenterAsDot = false; //normal
//var displayCameraCenterAsDot = true; //test

var numRandomOctahedrons = 99;
//var numRandomOctahedrons = 3;

/*fillGridByFunc(selq, 25, q=>{
	let xyz = q.toCartesian();
	let x = xyz[0], y = xyz[1], z = xyz[2];
	let xyzDist = Math.hypot(x*x,y*y,z*z);
	return xyzDist<20 && Math.abs(q.toCartesian()[0])<.5;
});
*/

var qgridBootDepth = 10;
//var qgridBootDepth = 5;
//var qgridBootDepth = 3;
//var qgridBootDepth = 2;
//var qgridBootDepth = 1;
//var qgridBootDepth = 0;

//var varyPointSizeByDistanceToCamera = true;
var varyPointSizeByDistanceToCamera = false;

//var displayCheckerboardDots = true; //toggled by a button press (space?)

var displayQgridDots = true; //toggled by a button press (Shift)

var drawDistanceMin = 1;
var drawDistanceMax = 1000;

//var displayDotDistances = true; //test
var displayDotDistances = false; //normal

var randColor = ()=>{
	let s = ''+randInt(2**24).toString(16)
	while(s.length < 6) s = '0'+s;
	return '#'+s;
};

//If made by Q(...) you can compare them using quadrayA===quadrayB or ==.
class Quadray{
	constructor(a = 0, b = 0, c = 0, d = 0){
		this.a = a;
		this.b = b;
		this.c = c;
		this.d = d;
		this.color = randColor(); //for UI only, not part of quadray math
	}
	
	abcd(){
		return [this.a, this.b, this.c, this.d];
	}

	normalized() {
		const minVal = Math.min(this.a, this.b, this.c, this.d);
		return new Quadray(
			this.a - minVal,
			this.b - minVal,
			this.c - minVal,
			this.d - minVal
		).dedup();
	}

	/*toCartesian(){
		const scale = 1 / ROOT2;
		const x = scale * (this.a - this.b - this.c + this.d);
		const y = scale * (this.a - this.b + this.c - this.d);
		const z = scale * (this.a + this.b - this.c - this.d);
		return [x, y, z];
	}*/
	toCartesian() {
		const [X, Y, Z] = this.toRawCartesian();
		return [X/ROOT2, Y/ROOT2, Z/ROOT2];
	}
	
	/*2025-8-10-220pET testing on browser console, looks correct but could be buggy in
	[[[
	Alright—per your request, here’s the only change: rewrite toScaledCartesian and fromScaledCartesian to use the raw path so they give exact integers with unit step and are mutual inverses on the CCP lattice.

	Replace just these two methods:

	js
	Copy
	Edit
	toScaledCartesian() {
		// exact integer lattice coords (unit spacing)
		return this.toRawCartesian();
	}

	static fromScaledCartesian([x, y, z]) {
		// exact inverse on the CCP lattice (x,y,z should be integers of same parity)
		return Quadray.fromRawCartesian([x, y, z]);
	}
	]]]
	
	Q(0,1,0,0).add(Q(0,0,1,0)).add(Q(0,1,0,0))+''
	'Q(0,2,1,0)'
	Q(0,1,0,0).add(Q(0,0,1,0)).add(Q(3,5,17,0))+''
	'Q(3,6,18,0)'
	Q(0,1,0,0).add(Q(0,0,1,0)).add(Q(3,5,17,0)).toRawCartesian()
	(3) [-21, 15, -9]
	Quadray.fromRawCartesian([-21, 15, -9]);
	Quadray {a: 3, b: 6, c: 18, d: 0, color: '#7ee61b'}
	Q(0,1,0,0).add(Q(0,0,1,0)).add(Q(3,5,17,0))+''
	'Q(3,6,18,0)'
	Q(0,1,0,0).add(Q(0,0,1,0)).add(Q(3,5,17,0)).add(Q(0,1,1,1))+''
	'Q(2,6,18,0)'
	Q(0,1,0,0).add(Q(0,0,1,0)).add(Q(3,5,17,0)).add(Q(0,1,1,1)).add(Q(0,1,1,1))+''
	'Q(1,6,18,0)'
	Q(0,1,0,0).add(Q(0,0,1,0)).add(Q(3,5,17,0)).add(Q(0,1,1,1)).add(Q(0,1,1,1)).add(Q(0,1,1,1))+''
	'Q(0,6,18,0)'	Q(0,1,0,0).add(Q(0,0,1,0)).add(Q(3,5,17,0)).add(Q(0,1,1,1)).add(Q(0,1,1,1)).add(Q(0,1,1,1)).add(Q(0,1,1,1))+''
	'Q(0,7,19,1)'
	Q(0,7,19,1).toRawCartesian()
	(3) [-25, 11, -13]
	Quadray.fromRawCartesian([-25, 11, -13])
	Quadray {a: 0, b: 7, c: 19, d: 1, color: '#b782c2'}
	Q(0,7,19,1).toCartesian()
	(3) [-17.677669529663685, 7.7781745930520225, -9.192388155425117]
	Q(0,7,19,1).mul(ROOT2).toCartesian()
	(3) [-25, 11, -13.000000000000002]
	Q(0,7,19,1).toRawCartesian()
	(3) [-25, 11, -13]
	Quadray.fromRawCartesian([-25, 11, -13])+''
	'Q(0,7,19,1)'
	*/
	toRawCartesian(){
		return [this.rawX(), this.rawY(), this.rawZ()]; //from (0,0,0) in raw3d, going 4 directions, you can reach 1/4 of the (int,int,int) cells.
	}
	
	rawX(){
		return this.a - this.b - this.c + this.d;
	}
	
	rawY(){
		return this.a - this.b + this.c - this.d;
	}
	
	rawZ(){
		return this.a + this.b - this.c - this.d;
	}
	
	/*toScaledCartesian(){ //TODO snap to integers?
		return this.mul(SCALE).toCartesian();
	}*/

	/*static fromCartesian([x, y, z]) {
		const scale = 1 / ROOT2;

		const a = scale * (Math.max(0, x) + Math.max(0, y) + Math.max(0, z));
		const b = scale * (Math.max(0, -x) + Math.max(0, -y) + Math.max(0, z));
		const c = scale * (Math.max(0, -x) + Math.max(0, y) + Math.max(0, -z));
		const d = scale * (Math.max(0, x) + Math.max(0, -y) + Math.max(0, -z));

		return new Quadray(a, b, c, d).normalized();
	}*/
	static fromCartesian([x, y, z]){
		//return Quadray.fromRawCartesian([x/ROOT2, y/ROOT2, z/ROOT2]);
		return Quadray.fromRawCartesian([x*ROOT2, y*ROOT2, z*ROOT2]);
	}
	
	/*static fromRawCartesian([x, y, z]){
		const a = Math.max(0, x) + Math.max(0, y) + Math.max(0, z);
		const b = Math.max(0, -x) + Math.max(0, -y) + Math.max(0, z);
		const c = Math.max(0, -x) + Math.max(0, y) + Math.max(0, -z);
		const d = Math.max(0, x) + Math.max(0, -y) + Math.max(0, -z);
		return new Quadray(a, b, c, d).normalized();
	}*/
	static fromRawCartesian([x, y, z]){
		const a = (Math.max(0,	x) + Math.max(0,	y) + Math.max(0,	z)) / 2;
		const b = (Math.max(0, -x) + Math.max(0, -y) + Math.max(0,	z)) / 2;
		const c = (Math.max(0, -x) + Math.max(0,	y) + Math.max(0, -z)) / 2;
		const d = (Math.max(0,	x) + Math.max(0, -y) + Math.max(0, -z)) / 2;
		return new Quadray(a, b, c, d).normalized();
	}
	
	/*static fromScaledCartesian([x, y, z]){ //TODO snap to integers?
		return Quadray.fromCartesian([x/SCALE, y/SCALE, z/SCALE]);
	}*/

	length(){
		const sumSq = this.a ** 2 + this.b ** 2 + this.c ** 2 + this.d ** 2;
		return Math.sqrt(sumSq / 2);
	}

	magnitude(){
		return this.length();
	}

	Add(other){ //Capital does not normalize
		return new Quadray(
			this.a + other.a,
			this.b + other.b,
			this.c + other.c,
			this.d + other.d
		).dedup();
	}
	
	add(other){ //lowercase normalizes
		return this.Add(other).normalized();
	}

	Mul(scalar) { //Capital does not normalize
		return new Quadray(
			this.a * scalar,
			this.b * scalar,
			this.c * scalar,
			this.d * scalar
		).dedup();
	}
	
	mul(other){ //lowercase normalizes
		return this.Mul(other).normalized();
	}
	
	Neg(){ //lowecase normalizes. Capital does not. If was normalized, will still be.
		return this.Mul(-1);
	}
	
	neg(){ //may be confusing if it was not normalized before jit will be now.
		return this.Neg().normalized();
	}

	//4d distance, even though a 3d surface with sharp corners in 4d is projected into a 3d smooth space
	static distance(q1, q2){
		const diff = new Quadray(
			q1.a - q2.a,
			q1.b - q2.b,
			q1.c - q2.c,
			q1.d - q2.d
		);
		return diff.length();
	}

	distance(other) {
		return Quadray.distance(this, other);
	}
	
	dist3d(other){
		return distance3d(this.toCartesian(),other.toCartesian());
	}
	
	distRaw3d(other){
		return distance3d(this.toRawCartesian(), other.toRawCartesian());
	}
	
	toString(){
		return 'Q('+this.a+','+this.b+','+this.c+','+this.d+')';
	}
	
	toDetailString(){
		return this+' (xyz '+JSON.stringify(this.toCartesian())+')';
	}
	
	//Returns an equal Quadray by a b c d, the first equal one in dedupQuadraysMap or creates it there.
	dedup(){
		let map = dedupQuadraysMap;
		map = map[this.a] || (map[this.a] = {});
		map = map[this.b] || (map[this.b] = {});
		map = map[this.c] || (map[this.c] = {});
		return map[this.d] || (map[this.d] = this);
	}
	
	//nearest quadray on CCP grid.
	//2025-8-16 added quadray.nearestCCP() func, so the gamepad buttons put octahedrons/tetrahedrons aligned to grid.
	nearestCCP = function(){
		return Quadray.fromRawCartesian( nearestCCPRawXyz(this.toRawCartesian()) );
	}

}

/* By GPT5, todo test.

	Nearest CCP/FCC site in *raw* xyz space (the one from toRawCartesian()).

	Lattice test in this space:
		- x,y,z are even integers, and
		- (x + y + z) ≡ 0 (mod 4).

	100% reliable minimal search:
		For each axis, the closest even is either evenFloor(v) or evenFloor(v)+2.
		Check the 2×2×2 = 8 combos; among them, exactly half pass the mod-4 test.
		Pick the one with smallest squared distance.

	Note: there’s a faster O(1) exact route via FCC coords
		u=(x+y−z)/4, v=(x+z−y)/4, w=(y+z−x)/4
		and rounding (with tiny ±1 tweaks), but this 8-point scan is
		simple, deterministic, and plenty fast.
		
Directions {a: Quadray, q: Quadray, s: Quadray, w: Quadray, d: Quadray, …} a : Quadray {a: 0, b: 1, c: -1, d: 0, color: '#d72ef9'} d : Quadray {a: 0, b: 1, c: 0, d: -1, color: '#6e6eea'} e : Quadray {a: 1, b: 0, c: 1, d: 2, color: '#33ba3e'} f : Quadray {a: 1, b: 0, c: -1, d: 0, color: '#eb9efa'} g : Quadray {a: 1, b: -1, c: 0, d: 0, color: '#e77b7c'} h : Quadray {a: 0, b: 0, c: 1, d: -1, color: '#06fb62'} q : Quadray {a: 1, b: 0, c: 2, d: 1, color: '#7ea16c'} r : Quadray {a: 0, b: 1, c: 2, d: 1, color: '#018f38'} s : Quadray {a: 1, b: 0, c: 0, d: -1, color: '#816be5'} t : Quadray {a: 0, b: 2, c: 1, d: 1, color: '#d57aba'} w : Quadray {a: 0, b: 1, c: 1, d: 2, color: '#0fb011'} y : Quadray {a: 1, b: 1, c: 0, d: 2, color: '#c4c603'} [[Prototype]] : Object Object.values(Directions).map(x=>x.toRawCartesian()) (12) [Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3)] 0 : (3) [0, -2, 2] 1 : (3) [0, 2, -2] 2 : (3) [0, 2, 2] 3 : (3) [0, -2, -2] 4 : (3) [-2, 0, 2] 5 : (3) [2, 0, -2] 6 : (3) [2, 0, 2] 7 : (3) [-2, 0, -2] 8 : (3) [2, 2, 0] 9 : (3) [-2, -2, 0] 10 : (3) [-2, 2, 0] 11 : (3) [2, -2, 0] length : 12 [[Prototype]] : Array(0)
*/
function nearestCCPRawXyz(xyz){
	let x = xyz[0], y = xyz[1], z = xyz[2];

	let ex = evenFloor(x);
	let ey = evenFloor(y);
	let ez = evenFloor(z);

	let bx = ex, by = ey, bz = ez;	// best so far
	let bd = Infinity;							// best squared distance

	for (let xi = ex; xi <= ex+2; xi += 2)
	for (let yi = ey; yi <= ey+2; yi += 2)
	for (let zi = ez; zi <= ez+2; zi += 2){
		// require (xi+yi+zi) ≡ 0 (mod 4)
		if ( ((xi + yi + zi) & 3) ) continue;

		let dx = xi - x, dy = yi - y, dz = zi - z;
		let s	= dx*dx + dy*dy + dz*dz;

		if (s < bd){ bd = s; bx = xi; by = yi; bz = zi; }
	}
	return [bx, by, bz];
}

// Largest even integer ≤ t (works for negatives too).
function evenFloor(t){
	return 2 * Math.floor(t / 2);
}


//PrimaryKey of a list of CCPBallRange's is (Directions.a,Directions.s) which are perpendicular
//to eachother in 3d as they are along 2 edges of an octahedron,
//and value is a range of Directions.d which is also on that octahedron.
//
// One immutable run [k0,k1) along D in the (i,j) column
//class CCPBallRange written by GPT5 2025-8-15. TODO test.
class CCPBallRange {
	constructor(i, j, k0, k1){			// k1 is exclusive
		this.i	= i|0; this.j	= j|0;
		this.k0 = k0|0; this.k1 = k1|0;
		if (this.k1 < this.k0) [this.k0, this.k1] = [this.k1, this.k0];
		Object.freeze(this);
	}
	
	get size(){
		return this.k1 - this.k0;
	}
	
	contains(i,j,k){
		return (i===this.i && j===this.j && this.containsK(k));
	}
	
	containsK(k){
		return this.k0 <= k && k < this.k1;
	}
	
	static singleton(i,j,k){ //range size 1
		return new CCPBallRange(i,j,k,k+1);
	}
	
	//returns a list of 0, 1, or 2 CCPBallRange's after the edit, to replace this one.
	removeK(k){
		if (!this.containsK(k)) return [this];		// not in this range → unchanged
		if (this.size === 1) return [];			// whole thing disappears

		if (k === this.k0) {
			// chop off leftmost unit
			return [ new CCPBallRange(this.i, this.j, this.k0+1, this.k1) ];
		}
		if (k === this.k1-1) {
			// chop off rightmost unit
			return [ new CCPBallRange(this.i, this.j, this.k0, this.k1-1) ];
		}
		// remove in the middle → split into two
		return [
			new CCPBallRange(this.i, this.j, this.k0, k),
			new CCPBallRange(this.i, this.j, k+1, this.k1),
		];
	}
}

// CCP-only sparse grid: (i,j) -> [CCPBallRange,...] (sorted, non-overlapping, coalesced)
//class CCPBallGrid written by GPT5 2025-8-15. TODO test.
/* This could be improved by not using concatted string keys (use 2 {} deep} and needs testing
to make sure its doing the 2d surface of 3d optimization (isnt making alot of size 1 CCPBallRange's,
and that it actually scales to big volumes. Test it by making 3d shaped paintbrushes and painting onto this.

Added CCPBallGrid and CCPBallRange classes. This is how its gonna store arbitrarily shaped 3d volumes just
by the balls on their surface. It will display a ball if it exists AND is beside at least
1 empty slot (no ball in that 1 of 12 slots).

PrimaryKey of list of CCPBallRange's is a compositeKey of [Directions.a,Directions.s],
and value is Directions.d, some integer multiple of all 3 of those.
TODO rename i and j and k to that.

CCPBallGrid {NBR: Array(12), QA: Quadray, QS: Quadray, QD: Quadray, cols: Map(15)}
NBR
: 
(12) [Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3)]
QA
: 
Quadray {a: 0, b: 1, c: -1, d: 0, color: '#2c3839'}
QD
: 
Quadray {a: 0, b: 1, c: 0, d: -1, color: '#d5177a'}
QS
: 
Quadray {a: 1, b: 0, c: 0, d: -1, color: '#a80dbc'}
cols
: 
Map(15)
[[Entries]]
0
: 
{"0,-1" => Array(1)}
1
: 
{"0,-2" => Array(1)}
2
: 
{"0,-3" => Array(1)}
3
: 
{"0,0" => Array(1)}
4
: 
{"0,1" => Array(1)}
key
: 
"0,1"
value
: 
Array(1)
0
: 
CCPBallRange {i: 0, j: 1, k0: 2, k1: 5}
length
: 
1
[[Prototype]]
: 
Array(0)
5
: 
{"0,2" => Array(1)}
6
: 
{"0,3" => Array(1)}
7
: 
{"0,4" => Array(1)}
8
: 
{"1,2" => Array(1)}
9
: 
{"2,3" => Array(1)}
key
: 
"2,3"
value
: 
Array(1)
0
: 
CCPBallRange {i: 2, j: 3, k0: 2, k1: 3}
length
: 
1
[[Prototype]]
: 
Array(0)
10
: 
{"3,4" => Array(1)}
11
: 
{"-1,0" => Array(1)}
12
: 
{"-2,-1" => Array(1)}
13
: 
{"-3,-2" => Array(1)}
14
: 
{"-4,-3" => Array(1)}
size
: 
15
[[Prototype]]
: 
Map
[[Prototype]]
: 
Object

ASD is IJK.
*/
class CCPBallGrid {
	constructor(){
		// Basis (do not flip—these are your CCP axes)
		this.QA = Directions.a; // Q(0,1,-1,0)
		this.QS = Directions.s; // Q(1,0,0,-1)
		this.QD = Directions.d; // Q(0,1,0,-1)
		this.cols = new Map();	// key "i,j" -> Array<CCPBallRange>
	}
	
	// add inside CCPBallGrid (e.g., right after constructor)
	NBR = [
		[ 1,	0,	0], [-1,	0,	0],
		[ 0,	1,	0], [ 0, -1,	0],
		[ 0,	0,	1], [ 0,	0, -1],
		[-1,	0,	1], [ 1,	0, -1],
		[ 0, -1,	1], [ 0,	1, -1],
		[ 1,	1, -1], [-1, -1,	1],
	];

	//get list of quadrays on the surface, excluding those with neighborCount 12.
	surfaceQuadrays(){
		let retList = [];
		for (const [key, list] of this.cols.entries()){
			if (!list.length) continue;
			const [iStr, jStr] = key.split(',');
			const i = +iStr, j = +jStr;

			for (const r of list){ //r is a CCPBallRange
				for (let k = r.k0; k < r.k1; k++){
					// solid here; check 12 neighbors
					/*let exposed = false;
					for (let t=0; t<this.NBR.length; t++){
						const di = i + this.NBR[t][0];
						const dj = j + this.NBR[t][1];
						const dk = k + this.NBR[t][2];
						if (!this.isSolid(di, dj, dk)){ exposed = true; break; }
					}
					if(exposed){
						retList.push(this.fromASD(i,j,k));
					}*/
					if(this.neighborCount(i,j,k)<12){
						retList.push(this.fromASD(i,j,k));
					}
				}
			}
		}
		return retList; //quadrays
	}


	// ---- Quadray <-> (i,j,k) on the CCP ASD lattice ----
	toASD(q){
		const {a,b,c,d} = q;
		const k = ((b - d) - (a - c)) / 2;
		const i = ((b - c) - k) / 2;
		const j = ((a - d) - k) / 2;
		return [i|0, j|0, k|0];
	}
	fromASD(i,j,k){
		return this.QA.mul(i).add(this.QS.mul(j)).add(this.QD.mul(k)).normalized();
	}

	// ---- sparse column storage helpers ----
	_key(i,j){ return ((i|0)+","+(j|0)); }
	_get(i,j){ return this.cols.get(this._key(i,j)) || []; }
	_set(i,j,arr){ const k=this._key(i,j); arr.length? this.cols.set(k,arr) : this.cols.delete(k); }

	// lower_bound by k0
	_lbK0(list, k){
		let lo=0, hi=list.length;
		while (lo<hi){ const m=(lo+hi)>>1; (list[m].k0 < k) ? lo=m+1 : hi=m; }
		return lo;
	}

	/*//assumes sorted, but its not: // public query
	isSolid(i,j,k){
		const list = this._get(i,j);
		// lower_bound on k1
		let lo=0, hi=list.length;
		while (lo<hi){ const m=(lo+hi)>>1; (list[m].k1 <= k) ? lo=m+1 : hi=m; }
		if (lo>=list.length) return false;
		const r = list[lo];
		return (r.k0 <= k && k < r.k1);
	}*/
	/** True if unit (i,j,k) currently contains a ball.
	*  Works even when the column list is unsorted or overlapping.
	*/
	isSolid(i,j,k){
		const list = this._get(i,j);
		for(const r of list){					// brute-force scan
			if(r.k0 <= k && k < r.k1) return true;
		}
		return false;
	}

	
	//Return how many of the 12 CCP-adjacent sites contain a ball.
	neighborCount(i,j,k){
		let n = 0;
		for (const [di,dj,dk] of this.NBR){
			if (this.isSolid(i+di, j+dj, k+dk)) n++;
		}
		return n;						// 0 … 12
	}
	
	shadeForNeighborCount(count){
		// digit = 3 … 15  (0x3 … 0xF)   →  "#333333" … "#ffffff"
		const d = (3 + count).toString(16);   // "3" … "f"
		return '#' + d.repeat(6);
	}
	
	/** This is called after modifying a list.
	It could be alot faster but its not the bottleneck so leave that for later if ever.
	Rebuild column (i,j) by brute‑forcing with isSolid; no Sets, no sort.
	Uses current ranges at (i,j) to define scan bounds, then rewrites that column.
	i is in units of Directions.a, and j in units of Directions.s, and k in units of Directions.d.
	*/
	rebuildListIJ(i,j){
		const list = this._get(i,j);
		if (!list || list.length === 0){
			this._set(i,j,[]);
			return [];
		}

		// find scan bounds
		let minK = Infinity, maxK = -Infinity;
		for (const r of list){
			if (r.k0 < minK) minK = r.k0;
			if (r.k1-1 > maxK) maxK = r.k1-1;
		}
		if (!isFinite(minK)){
			this._set(i,j,[]);
			return [];
		}

		// sweep k=minK..maxK using isSolid and build contiguous runs
		const out = [];
		let runStart = null;

		for (let k=minK; k<=maxK; k++){
			if (this.isSolid(i,j,k)){
				if (runStart === null) runStart = k;
			}else if (runStart !== null){
				out.push(new CCPBallRange(i,j, runStart, k));
				runStart = null;
			}
		}
		if (runStart !== null){
			out.push(new CCPBallRange(i,j, runStart, maxK+1));
		}

		this._set(i,j,out);
		return out;
	}

	// ───────── add/remove a single ball ─────────
	addQuadray(q){
		const [i,j,k] = this.toASD(q);
		if (this.isSolid(i,j,k)) return;						// already there

		// append singleton then normalise
		const list = this._get(i,j).slice();
		list.push( CCPBallRange.singleton(i,j,k) );
		this._set(i,j,list);
		this.rebuildListIJ(i,j);
	}

	removeQuadray(q){
		const [i,j,k] = this.toASD(q);
		if (!this.isSolid(i,j,k)) return;						// nothing to do

		// let each range split itself, then normalise
		let next = [];
		for (const r of this._get(i,j)) next.push(...r.removeK(k));
		this._set(i,j,next);
		this.rebuildListIJ(i,j);
	}
	
	clear(){
		this.cols.clear();
	}
	
		//load 1 i_j list of state, alternating k0 k1 k0 k1...
	loadIJ(i,j,kEnds){
		const list=[];
		for(let t=0;t<kEnds.length;t+=2){
			list.push(new CCPBallRange(i,j,kEnds[t],kEnds[t+1]));
		}
		this._set(i,j,list);
		this.rebuildListIJ(i,j);	// coalesce once
	}

	saveIJ(i,j){
		const out=[];
		for(const r of this._get(i,j)) out.push(r.k0,r.k1);
		return out;					// [k0,k1,k0,k1,…]
	}

	//after clear() or as diffs from whats already loaded, load what comes out of save().
	load(map){
		this.clear();
		for(const key in map){
			const [i,j]=key.split(',').map(Number);
			this.loadIJ(i,j,map[key]);
		}
	}


	//get jsonable {} of this state, you can use with loadIJ
	save(){
		const obj=Object.create(null);	// { "i,j": [k0,k1,…], … }
		for(const [key] of this.cols){
			const [i,j]=key.split(',').map(Number);
			obj[key]=this.saveIJ(i,j);
		}
		return obj;
	}

}



var distance3d = (xyz1, xyz2)=>Math.hypot(xyz1[0]-xyz2[0], xyz1[1]-xyz2[1], xyz1[2]-xyz2[2]);

var Len = xyz=>Math.hypot(xyz[0], xyz[1], xyz[2]);

//TriZngle made of 3 quadray points as its primaryKey, and a color as mutable data.
//If made by T(...) you can compare them using TriZ===triB or ==.
class Tri{
	constructor(e, f, g){
		this.e = e;
		this.f = f;
		this.g = g;
		this.color = randColor(); //for UI only, not part of quadray math
	}
	
	primaryKey(){
		return 'T('+this.e+','+this.f+','+this.g+')';
	}
	
	toString(){
		return this.primaryKey();
	}
	
	//toggle if this tri is displayed or not
	tog(){
		ToggleGameTri(this);
	}
	
	dedup(){
		let primaryKey = this.primaryKey();
		return dedupTriMap[primaryKey] || (dedupTriMap[primaryKey] = this);
	}
}

//given a quadray, returns a [] list of 6 quadrays similar to
//"const octCorners = [[0,0,0],[0,0,2],[0,-1,1],[0,1,1],[-1,0,1],[1,0,1]];"
//but as quadrays instead of xyz.
/*var oct6CornersAtQuadray = q=>{
	let A = CoreDirections[0].Neg();
	let B = CoreDirections[4].Neg();
	return [
		q,
		q.add(A).add(B),
		q.add(CoreDirections[1]),
		q.add(CoreDirections[5]),
		q.add(CoreDirections[5]).add(CoreDirections[3]),
		q.add(CoreDirections[3].Neg()).add(CoreDirections[1]),
	];
};*/
/*var oct6CornersAtQuadray = q=>{ //from gpt-o3 2025-8-4
	let A = CoreDirections[0].Neg();	 // same as before
	// let B = CoreDirections[4].Neg(); // ❌ old duplicate path
	let B = CoreDirections[1];		 // ✅ identical to the old result

	return [
		q,
		q.add(A).add(B),
		q.add(CoreDirections[1]),
		// q.add(CoreDirections[5]),					 ❌
		q.add(CoreDirections[0].Neg()),				 // ✅ same offset
		// q.add(CoreDirections[5]).add(CoreDirections[3]), ❌
		q.add(CoreDirections[0].Neg()).add(CoreDirections[3]), // ✅
		q.add(CoreDirections[3].Neg()).add(CoreDirections[1]),
	];
};*/
var oct6CornersAtQuadray=q=>{ //from gpt-o3 2025-8-4
	let A=CoreDirections[0].Neg();		// same as old CoreDirections[5]
	let B=CoreDirections[1];			// same as old CoreDirections[4].Neg()
	return[
		q,								// 0 bottom apex
		q.add(A).add(B),				// 1 opposite apex
		q.add(CoreDirections[1]),		// 2
		q.add(A),						// 3
		q.add(A).add(CoreDirections[3]),// 4
		q.add(CoreDirections[3].Neg()).add(CoreDirections[1])// 5
	];
};



var TriZ4CornersAtQuadray = ray=>([
	ray, //the main corner shared between octahedron and 2 tetrahedrons
	ray.add(Directions.e),
	ray.add(Directions.q), //the secondary corner shared between octahedron and 2 tetrahedrons
	ray.add(Directions.q).add(Directions.f),
]);

var TriX4CornersAtQuadray = ray=>([
	ray, //the main corner shared between octahedron and 2 tetrahedrons
	ray.add(Directions.r),
	ray.add(Directions.q), //the secondary corner shared between octahedron and 2 tetrahedrons
	ray.add(Directions.q).add(Directions.d),
]);

var tetZTrisAtQuadray = ray=>tetTrisAtFourCorners(TriZ4CornersAtQuadray(ray));

var tetXTrisAtQuadray = ray=>tetTrisAtFourCorners(TriX4CornersAtQuadray(ray));

var tetTrisAtFourCorners = corners=>([
	T(corners[1], corners[2], corners[3]),
	T(corners[0], corners[2], corners[3]),
	T(corners[0], corners[1], corners[3]),
	T(corners[0], corners[1], corners[2]),
]);


//returns a [] list of 8 Tri's which are each made of 3 quadray's, forming an octahedron
//one of whose corners is the given quadray.
var octTrisAtQuadray = q=>{
	let corners = oct6CornersAtQuadray(q); //6
	let ret = octahedronFaces.map(
		threeInts=>T(corners[threeInts[0]],corners[threeInts[1]],corners[threeInts[2]]));
	//while(ret.length>4) ret.pop(); //FIXME remove this
	return ret;
};

var gameTris = {}; //3 quadrays each, not the [x,y,z] kind.

//A Tri made of 3 Quadrays, deduped.
var AddGameTri = tri=>{
	return gameTris[tri.primaryKey()] = tri;
};

var RemGameTri = tri=>{
	delete gameTris[tri.primaryKey()];
};

var HasGameTri = tri=>{
	return !!gameTris[tri.primaryKey()];
};

var ToggleGameTri = tri=>{
	if(HasGameTri(tri)){
		RemGameTri(tri);
	}else{
		AddGameTri(tri);
	}
	gridChanged = true;
};

//var selPaintbrushName = 'oneBall';
var selPaintbrushName = ()=>(dom('paintbrushSelect').value || 'repeatD10');

//This contains all octahedrons and tetrahedrons as 1 quadray and 1 group name each.
//grid.oct is a SEt if q is a quadray whose bottom corner is q. Theres 6 corners of it.
//Similarly grid.tetZ and grid.tetC are the 2 tetrahedrons sharing that same q. For many q.
var grid = {
	oct: new Set(),
	tetZ: new Set(),
	tetC: new Set(),
};

var gridToMap = grid=>{
	let map = {};
	for(let key in grid){
		map[key] = [];
		for(let q of grid[key].keys()){
			map[key].push(q.abcd());
		}
	}
	return map;
};

var toggleQuadrayInSet = (set,q)=>{
	if(set[q]) set.remove(q);
	else set.add(q);
};

var toggleOctAtQuadray = q=>{
	console.log('toggleOctAtQuadray q='+q);
	let sixCorners = oct6CornersAtQuadray(q);
	for(let c of sixCorners) ToggleDot(c);
	/*ToggleDot(sixCorners[0]); //base
	ToggleDot(sixCorners[1]); //opposite of base, 2 edges away. the other 4 are the 4 corners between those 2.
	ToggleDot(sixCorners[2]);
	ToggleDot(sixCorners[3]);
	ToggleDot(sixCorners[4]);
	ToggleDot(sixCorners[5]);
	*/
	let tris = octTrisAtQuadray(q);
	for(let tri of tris){
		ToggleGameTri(tri);
	}
	toggleQuadrayInSet(grid.oct, q);
	gridChanged = true;
};

var addOctAtQuadray = q=>{
	console.log('addOctAtQuadray q='+q);
	let sixCorners = oct6CornersAtQuadray(q);
	for(let c of sixCorners) ToggleDot(c);
	let tris = octTrisAtQuadray(q);
	for(let tri of tris){
		AddGameTri(tri);
	}
	grid.oct.add(q);
	gridChanged = true;
};

//Each quadray on the grid, which is like a 3d checkerboard with 1 of the parities missing,
//is the primaryKey of 1 octahedron and 2 tetrahedrons.
var toggleTetZAtQuadray = q=>{
	console.log('toggleTetZAtQuadray q='+q);
	let corners = TriZ4CornersAtQuadray(q);
	for(let c of corners) ToggleDot(c);
	let tris = tetZTrisAtQuadray(q);
	for(let tri of tris){
		ToggleGameTri(tri);
	}
	toggleQuadrayInSet(grid.tetZ, q);
	gridChanged = true;
};

var addTetZAtQuadray = q=>{
	console.log('toggleTetZAtQuadray q='+q);
	let corners = TriZ4CornersAtQuadray(q);
	for(let c of corners) ToggleDot(c);
	let tris = tetZTrisAtQuadray(q);
	for(let tri of tris){
		AddGameTri(tri);
	}
	grid.tetZ.add(q);
	gridChanged = true;
};

var toggleTetCAtQuadray = q=>{
	console.log('toggleTetCAtQuadray q='+q);
	let corners = TriX4CornersAtQuadray(q);
	for(let c of corners) ToggleDot(c);
	let tris = tetXTrisAtQuadray(q);
	for(let tri of tris){
		ToggleGameTri(tri);
	}
	toggleQuadrayInSet(grid.tetC, q);
	gridChanged = true;
};

var addTetCAtQuadray = q=>{
	console.log('toggleTetCAtQuadray q='+q);
	let corners = TriX4CornersAtQuadray(q);
	for(let c of corners) ToggleDot(c);
	let tris = tetXTrisAtQuadray(q);
	for(let tri of tris){
		AddGameTri(tri);
	}
	grid.tetC.add(q);
	gridChanged = true;
};

var T = (e,f,g)=>(new Tri(e,f,g).dedup());

var dedupTriMap = {};

//dedupQuadraysMap[q.a][q.b][q.c][q.d] === q;
var dedupQuadraysMap = {};

//dedups quadray
var Q = (a,b,c,d)=>(new Quadray(a,b,c,d).dedup());

//QGridDots and QDots are both quadray 3d points.
//QDots (random colors as of 2025-8-4) are made by button presses,
//a path you move along, showing your 3d cursor.
//QGridDots (blue as of 2025-8-4 and earlier) are generated outward from selq which is the quadray cursor.
var QGridDots = {};

//Quadray.toString() to Quadray, to display
var QDots = {};

//like QDots but balls instead of dots
var QBalls = {};				//Quadray.toString() ➜ Quadray
var AddBall = q=>{
	if(dom('isCcpBallGrid').checked){
		ccp.addQuadray(q);
	}else{
		QBalls[q] = q; //q.toString()
	}
	//dont gridChanged cuz thats just for the octahedron and tetrahedron grid
};
var RemBall = q=>{
	if(dom('isCcpBallGrid').checked){
		ccp.removeQuadray(q);
	}else{
		delete QBalls[q]; //q.toString()
	}
	//dont gridChanged cuz thats just for the octahedron and tetrahedron grid
};
var ToggleBall = q=>{
	if(QBalls[q]){
		RemBall(q);
	}else{
		AddBall(q);
	}
};

const ballRadius = 1;

//These are created again each graphics/draw cycle (about 1/60 second), not stored between that.
//Tri (triangle) with type 'tri', or Quadray with type 'QGridDot' or 'QDot' or 'ball'.
class Drawable{
	constructor(type,obj,xyz,color=null){
		this.type = type;			//'ball'|'tri' (later 'dot'…)
		this.obj = obj;			//Quadray or Tri
		this.xyz = xyz;			//world-space [x,y,z]
		this.color = color; //if nonnull, overrides color at quadray etc.
		this.depth = dotProdOfXYZAlongCamForward(xyz);	//bigger = farther
	}
	draw(){ //on canvas
		let isQuat = isQuatCam();
		if(this.type==='ball'){
			let fill = true;
			let isConePlaneIntersection = dom('isConePlaneIntersection').checked;
			//paintBall(this.xyz, ballRadius, this.obj.color, fill, isConePlaneIntersection);	//throws if !isQuatCam()
			const clr = this.color ?? this.obj.color;   // <-- new
			paintBall(this.xyz, ballRadius, clr, fill, isConePlaneIntersection);
		}else if(this.type==='QGridDot' || this.type==='QDot'){
			//QGridDot displays as blue instead of its own color
			let color = this.type==='QDot' ? this.obj.color : 'blue';
			//paintXYZColor(isQuat ? q.toCartesian() : UnscaleGrid(q.toCartesian()), color);
			paintXYZColor(isQuat ? this.xyz : UnscaleGrid(this.xyz), color);
		}else if(this.type==='tri'){
			let tri = this.obj;
			drawTriangle(
				//UnscaleGrid cuz theres 2 coordinate systems that ive aligned here by scaling one by ROOT2. [x,y,z] vs quadray.
				//The 2 coordinate systems were aligned in QuadGrid.html but the 3d one mostly removed (except camera) in QuadGrid2.html.
				isQuat ? tri.e.toCartesian() : UnscaleGrid(tri.e.toCartesian()),
				isQuat ? tri.f.toCartesian() : UnscaleGrid(tri.f.toCartesian()),
				isQuat ? tri.g.toCartesian() : UnscaleGrid(tri.g.toCartesian()),
				tri.color
			);
		}else{
			Err('Unknown drawable.type='+this.type);
		}
	}
}

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
//canvas.width = window.innerWidth;
//canvas.height = window.innerHeight;

// mouse/drag/zoom/rotate setup
//let offsetX = canvas.width / 2;
//let offsetY = canvas.height / 2;
let drag = false, rotateDrag = false, lastX = 0, lastY = 0;

/*function resizeCanvas(){
	console.log('resizeCanvas');
	const rect = canvas.getBoundingClientRect();			// top-edge under the UI
	canvas.width	= window.innerWidth;								// full viewport width
	canvas.height = window.innerHeight - rect.top;		// only the exposed height
	offsetX = canvas.width / 2;
	offsetY = canvas.height / 2;
}*/
function resizeCanvas(){
	const rect	 = canvas.getBoundingClientRect();					 // top of canvas below UI
	const visW	 = window.innerWidth;
	const visH	 = window.innerHeight - rect.top;						// exposed height

	// same numbers for both the drawing buffer *and* the DOM element
	canvas.width	= visW;
	canvas.height = visH;
	canvas.style.width	= visW + 'px';
	canvas.style.height = visH + 'px';

	offsetX = canvas.width	/ 2;				// legacy vars for the old camera path
	offsetY = canvas.height / 2;
}
resizeCanvas();												 // run once now
window.addEventListener('resize', resizeCanvas);	// run on every window resize

let zoom = 1.0;
let angleX = 0, angleY = 0;
let cubeSize = 700;

//selected Quadray
//var selq = Q(0,0,0,0);
//var selq = Quadray.fromCartesian(
//	indexToXYZ(indexNearXYZ([side/2,side/2,side/2]))); //start on one of the 3d grid points
//var selq = Q(ROOT2*5,0,0,0) //selq starts as Q(7.0710678118654755,0,0,0); //was: var selq = Q(7.071067811865474,0,0,0)
//var selq = Q(7,0,0,0); //We dont need the 3d coordinate system anymore, so use integer 7 instead of 7.071067811865474 as of 2025-6-12.

var selq = Q(0,0,0,0); //We dont need the 3d coordinate system anymore, so use integer 7 instead of 7.071067811865474 as of 2025-6-12.
//arbitrary view I found looks good when start at Q(0,0,0,0)
offsetX = 731;
offsetY = 141;
zoom = 0.38742048900000015;
angleX = 0.10999999999999997;
angleY = 1.0100000000000038;

var quadrayAve = quadrays=>{
	let sum = Q(0,0,0,0);
	for(let q of quadrays) sum = sum.add(q);
	return sum.mul(1/quadrays.length);
};

console.log('selq starts as '+selq); //selq starts as Q(7.071067811865474,0,0,0) 2025-6-5-715aET
console.log('selq='+selq.toDetailString()); //selq=Q(7.071067811865474,0,0,0) (xyz [4.999999999999998,4.999999999999998,4.999999999999998])

//map of keyboard button name to Quadray for moving selq (the selected Quadray)
//will need to scale the 3d checkerboard/parity grid by 1/ROOT2 or is it ROOT2,
//cuz changing these from ROOT2 to 1.
/*var CoreDirections = [
	Q(0,	1, -1,	0),	// from [0, -1, 1]
	Q(1,	0,	0, -1),	// from [0,	1, 1]
	Q(0,	1,	0, -1),	// from [-1, 0, 1]
	Q(1,	0, -1,	0),	// from [1, 0, 1]
	Q(-1, 0,	0,	1),	// from [0, -1, -1]
	Q(0, -1, 1,	0),	 // from [0, 1, -1]
];
if(CoreDirections[1].normalized() !== CoreDirections[4].Neg().normalized()){
	Err('CoreDirections[1] !== CoreDirections[4].Neg()');
}else console.log('Verified buggy duplicate mirror exists: CoreDirections[1] !== CoreDirections[4].Neg() normed.');
if(CoreDirections[0].normalized() !== CoreDirections[5].Neg().normalized()){
	Err('CoreDirections[0] !== CoreDirections[5].Neg()');
}else console.log('Verified buggy duplicate mirror exists: CoreDirections[0] !== CoreDirections[5].Neg() normed.');
*/
/*var CoreDirections = [
	Q(0,	1, -1,	0),	// from [0, -1, 1]
	Q(1,	0,	0, -1),	// from [0,	1, 1]
	Q(0,	1,	0, -1),	// from [-1, 0, 1]
	Q(1,	0, -1,	0),	// from [1, 0, 1]
];*/
/*var CoreDirections=[ //from gpt-o3 2025-8-4
	Q(1,-1,0,0),	// +x –y
	Q(1,0,-1,0),	// +x –z
	Q(1,0,0,-1),	// +x –w
	Q(0,1,-1,0),	// +y –z
	Q(0,1,0,-1),	// +y –w
	Q(0,0,1,-1)		// +z –w
];*/
/*var CoreDirections = [ //from gpt-o3 2025-8-4
	Q(0,	1,-1, 0),	 // 0	 unchanged
	Q(1,	0, 0,-1),	 // 1
	Q(0,	1, 0,-1),	 // 2
	Q(1,	0,-1, 0),	 // 3
	//was Q(-1,0,0, 1)	→ duplicate of 1
	Q(1,-1, 0, 0),	// 4	NEW unique dir
	//was Q( 0,-1,1, 0) → duplicate of 0
	Q(0, 0, 1,-1)	 // 5	NEW unique dir
];*/
var CoreDirections = [
	Q(0,	1,-1, 0),	 // 0	(keep)
	Q(1,	0, 0,-1),	 // 1
	Q(0,	1, 0,-1),	 // 2
	Q(1,	0,-1, 0),	 // 3
	Q(1,-1, 0, 0),	// 4	← NEW (was −1,0,0,1)
	Q(0, 0, 1,-1)	 // 5	← NEW (was	0,-1,1,0)
];
var CoreDirectionsNormed = CoreDirections.map(x=>x.normalized());
for(let i=0; i<CoreDirections.length; i++){
	if(CoreDirections[i] !== CoreDirectionsNormed[i]){
		console.log('CoreDirections['+i+'] ('+CoreDirections[i]+') !== CoreDirectionsNormed['+i+'] ('+CoreDirectionsNormed[i]+')');
	}
}
//CoreDirections are NOT normalized. FIXME?
//JSON.stringify(CoreDirections.map(x=>({raw:x,norm:x.normalized()})))
//[{"raw":{"a":0,"b":1,"c":-1,"d":0,"color":"#766a38"},"norm":{"a":1,"b":2,"c":0,"d":1,"color":"#15bdf8"}},{"raw":{"a":1,"b":0,"c":0,"d":-1,"color":"#1b9bb1"},"norm":{"a":2,"b":1,"c":1,"d":0,"color":"#bdd5d4"}},{"raw":{"a":0,"b":1,"c":0,"d":-1,"color":"#4baec0"},"norm":{"a":1,"b":2,"c":1,"d":0,"color":"#a4df1e"}},{"raw":{"a":1,"b":0,"c":-1,"d":0,"color":"#365d4a"},"norm":{"a":2,"b":1,"c":0,"d":1,"color":"#9b4185"}},{"raw":{"a":-1,"b":0,"c":0,"d":1,"color":"#5daa6c"},"norm":{"a":0,"b":1,"c":1,"d":2,"color":"#324aac"}},{"raw":{"a":0,"b":-1,"c":1,"d":0,"color":"#f704cd"},"norm":{"a":1,"b":0,"c":2,"d":1,"color":"#81b0a6"}}]

//Put your left hand on 4 of asdfgh, and the 6 keys above them.
//Slide your left hand between asdf sdfg dfgh, so you control 4 of the 6 directions at any one time.
//Push space to turn on/off the octahedron whose bottom corner is at the flashing selq (quadray) cursor.
var Directions = {
	a: CoreDirections[0],
	q: CoreDirections[0].mul(-1),
	
	s: CoreDirections[1],
	w: CoreDirections[1].mul(-1),
	
	d: CoreDirections[2],
	e: CoreDirections[2].mul(-1),
	
	f: CoreDirections[3],
	r: CoreDirections[3].mul(-1),
	
	g: CoreDirections[4],
	t: CoreDirections[4].mul(-1),
	
	h: CoreDirections[5],
	y: CoreDirections[5].mul(-1),
};

//mask these together in paintbrushes
const PB_OTHER = 1, PB_TETZ = 2, PB_OCT = 4, PB_TETC = 8, PB_BALL = 16;

var paintbrushes = {
	/*fillGridByFuncOutTo4_noDelete: {
		func: isPaintElseUnpaint=>{
			fillGridByFunc(targetQ(), 2, ()=>true); //only does paint, not unpaint as of 2025-8-17'
		}
	},*/
	oneOctahedron: {
		mask: PB_OCT,
		quads: [Q(0,0,0,0)]
	},
	oneTetrahedronZ:{
		mask: PB_TETZ,
		quads: [Q(0,0,0,0)]
	},
	oneTetrahedronC:{
		mask: PB_TETC,
		quads: [Q(0,0,0,0)]
	},
	bothTets:{
		mask: PB_TETZ | PB_TETC,
		quads: [Q(0,0,0,0)]
	},
	bothTetsAndOct:{
		mask: PB_TETZ | PB_OCT | PB_TETC,
		quads: [Q(0,0,0,0)]
	},
	bothTetsAndOct:{
		mask: PB_TETZ | PB_OCT | PB_TETC,
		quads: [Q(0,0,0,0)]
	},
	oneOfEach:{
		mask: PB_TETZ | PB_OCT | PB_TETC | PB_BALL,
		quads: [Q(0,0,0,0)]
	},
	oneBall: {
		mask: PB_BALL,
		quads: [Q(0,0,0,0)]
	},
	repeatA2: {
		mask: PB_BALL,
		quads: [Q(0,0,0,0), Directions.a]
	},
	repeatA3: {
		mask: PB_BALL,
		quads: [Q(0,0,0,0), Directions.a, Directions.a.add(Directions.a)]
	},
	repeatA4: {
		mask: PB_BALL,
		quads: [Q(0,0,0,0), Directions.a, Directions.a.add(Directions.a), Directions.a.add(Directions.a).add(Directions.a)]
	},
	repeatA5: {
		mask: PB_BALL,
		quads: [
			Q(0,0,0,0), Directions.a, Directions.a.add(Directions.a),
			Directions.a.add(Directions.a).add(Directions.a), Directions.a.add(Directions.a).add(Directions.a).add(Directions.a)
		]
	},
	repeatS5: {
		mask: PB_BALL,
		quads: [
			Q(0,0,0,0), Directions.s, Directions.s.add(Directions.s),
			Directions.s.add(Directions.s).add(Directions.s), Directions.s.add(Directions.s).add(Directions.s).add(Directions.s)
		]
	},
	repeatD3: {
		mask: PB_BALL,
		quads: [
			Q(0,0,0,0), Directions.d, Directions.d.add(Directions.d)
		]
	},
	repeatD5: {
		mask: PB_BALL,
		quads: [
			Q(0,0,0,0), Directions.d, Directions.d.add(Directions.d),
			Directions.d.add(Directions.d).add(Directions.d), Directions.d.add(Directions.d).add(Directions.d).add(Directions.d)
		]
	},
	repeatD10: {
		mask: PB_BALL,
		quads: [
			Q(0,0,0,0), Directions.d, Directions.d.add(Directions.d),
			Directions.d.add(Directions.d).add(Directions.d),
			Directions.d.add(Directions.d).add(Directions.d).add(Directions.d),
			Directions.d.add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d),
			Directions.d.add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d),
			Directions.d.add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d),
			Directions.d.add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d),
			Directions.d.add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d).add(Directions.d)
		]
	},
	distance0To1_13Balls: {
		mask: PB_BALL,
		quads: [
			Q(0,0,0,0), Directions.a, Directions.q,
			Directions.s, Directions.w,
			Directions.d, Directions.e,
			Directions.f, Directions.r,
			Directions.g, Directions.t,
			Directions.h, Directions.y
		]
	},
	/*getRandomBallsPaintbrush: {
		mask: PB_OTHER,
		paintbrushNames: ['oneBall', 'repeatA2', 'repeatA3', 'repeatA4', 'repeatA5', 'repeatS5', 'distance0To1_13Balls']
		quads: [], //FIXME?
	}*/
};

// one CCP grid for the whole app
const ccp = new CCPBallGrid();

var addDirectionsBalls = ()=>{
	for(let q of Object.values(Directions)){
		AddBall(q);
	}
};

//Quadray param, adds or removes it from QDots
var ToggleDot = q=>{
	if(HasDot(q)){
		RemDot(q);
	}else{
		AddDot(q);
	}
};

var AddColoredDots = (quadrays,color)=>{
	for(let q of quadrays){
		q.color = color;
		RemDot(q); //in case it had a different color
		AddDot(q);
	}
};

var AddQgridDot = q=>{
	q = q.dedup();
	QGridDots[q] = q
};

/*//recurse Directions to fill QGridDots outward from q, depth recursions deep.
//This is used to fill in the first dots (TODO) and 
var AddQgridDotsAround = (q,depth)=>{
};*/
var expandQgridDotsOneDeeper = ()=>{
	let directions = Object.values(Directions);
	for(let q of Object.values(QGridDots)){
		for(let qDirection of directions){
			AddQgridDot(q.add(qDirection));
		}
	}
};

//returns list of quadrays around center, aligned on grid, hops number of CoreDirections hops outward, without duplicates.
//If hops is 0, it just returns center. if 3 then 3 key presses of distance away. any integer.
var gridDotsNear = (center, hops)=>{
	let set = new Set(); //of quadrays
	set.add(center);
	//let directions = Object.values(CoreDirections); //normal
	let directions = Object.values(Directions); //normal
	//let directions = [CoreDirections[0],CoreDirections[1],CoreDirections[2],CoreDirections[3]]; //test, ignore last 2 cuz was duplicates mirrored
	for(let h=1; h<=hops; h++){
		let setList = [...(set.keys())]; //copy of the Set
		for(let q of setList){
			for(let qDirection of directions){
				let q2 = q.add(qDirection); //may already be in Set or not
				set.add(q2);
			}
			if(set.size > 1000000){
				Err('Too big, set.size='+set.size);
			}
		}
	}
	return [...set]; //list of quadrays
};

var AddDot = q=>{
	QDots[q] = q
};

var RemDot = q=>{
	delete QDots[q];
};

var HasDot = q=>!!QDots[q];


//of earlier 3d coordinate system before there were quadrays, that camera still works in (rotate/inverseRotate).
//If its rotating around the wrong point, you might need to adjust this, but would only happen if you build far and wide.
const side = 10;

const octCorners = [[0,0,0],[0,0,2],[0,-1,1],[0,1,1],[-1,0,1],[1,0,1]];

let Add = (vecA,vecB)=>[vecA[0]+vecB[0], vecA[1]+vecB[1], vecA[2]+vecB[2]];
let Sub = (vecA,vecB)=>[vecA[0]-vecB[0], vecA[1]-vecB[1], vecA[2]-vecB[2]];

let VecMulScalar = (vecA,scalar)=>[vecA[0]*scalar, vecA[1]*scalar, vecA[2]*scalar];

//made of Tri's which are each made of 3 Quadrays
const qOctCorners = [];
for(let corner3d of octCorners){
	let scaledCorner3d = VecMulScalar(corner3d,ROOT2);
	qOctCorners.push(Quadray.fromCartesian(scaledCorner3d));
}
console.log('octCorners = '+JSON.stringify(octCorners));
console.log('qOctCorners = '+qOctCorners.join(' '));

//each face is 3 indexs in octCorners (0..5). Each is an equilateral TriZngle.
//Every tetrahedron face is some octahedron's face.
const octahedronFaces = [
	[0, 2, 4],
	[0, 4, 3],
	[0, 3, 5],
	[0, 5, 2],
	[1, 2, 5],
	[1, 5, 3],
	[1, 3, 4],
	[1, 4, 2]
];

//let Scale3d = vec=>VecMulScalar(vec,ROOT2);
//let UnScale3d = vec=>VecMulScalar(vec,1/ROOT2);

let Dist = (vecA,vecB)=>Math.hypot(vecA[0]-vecB[0], vecA[1]-vecB[1], vecA[2]-vecB[2]);


//Display the 3d grid differently than its actual coordinates to deal with the ROOT2 scaling
//of quadrays being changed to 1 (1,0,0,0) instead of (ROOT2,0,0,0) etc,
//and that the origin is side/2 instead of 0 which it rotates around.
let ScaleGrid = v=>[
	side/2+(v[0]-side/2)*ROOT2,
	side/2+(v[1]-side/2)*ROOT2,
	side/2+(v[2]-side/2)*ROOT2,
];
//const UnscaleGrid = ([x,y,z])=>[x / ROOT2, y / ROOT2, z / ROOT2];
const UnscaleGrid = ([x, y, z]) => [
	(x - side/2) / ROOT2 + side/2,
	(y - side/2) / ROOT2 + side/2,
	(z - side/2) / ROOT2 + side/2
];
let testPoint55 = [2,79,15];
let scaled_testPoint55 = ScaleGrid(testPoint55);
let rebuilt_testPoint55 = UnscaleGrid(scaled_testPoint55);
let dist_testPoint55 = Dist(testPoint55,rebuilt_testPoint55);
if(dist_testPoint55>.000001) Err('ScaleGrid/UnscaleGrid test fail, testPoint55='+JSON.stringify(testPoint55)+
	' rebuilt_testPoint55='+JSON.stringify(rebuilt_testPoint55));
console.log('ScaleGrid/UnscaleGrid test pass');


let Ave3 = (vecA,vecB,vecC)=>[
	(vecA[0]+vecB[0]+vecC[0])/3,
	(vecA[1]+vecB[1]+vecC[1])/3,
	(vecA[2]+vecB[2]+vecC[2])/3
];

canvas.addEventListener("mousedown", function(e){
	if (e.button === 2) rotateDrag = true;
	else if (e.button === 0) drag = true;
	lastX = e.clientX;
	lastY = e.clientY;
	canvas.style.cursor = 'grabbing';
});
canvas.addEventListener("mouseup", function(e){
	drag = rotateDrag = false;
	canvas.style.cursor = 'grab';
});
canvas.addEventListener("contextmenu", function(e){ e.preventDefault()} );
canvas.addEventListener("mousemove", function(e){
	let mouseMovedXPixels = e.clientX - lastX;
	let mouseMovedYPixels = e.clientY - lastY;
	let mul = moveSpd*secondMoveSpeedMul;
	if(drag&&rotateDrag){ //both mouse buttons held, go forward/backward like wheel
		moveCamera(-3*mouseMovedYPixels*mul, 0, 0);
	}else if(drag){
		if(isQuatCam()){
			//moveCamera(fwdVal*moveSpd*dt, upDown*moveSpd*dt, leftRight*moveSpd*dt);
			moveCamera(0, -mouseMovedYPixels*mul, mouseMovedXPixels*mul);
		}else{
			offsetX += mouseMovedXPixels;
			offsetY += mouseMovedYPixels;
		}
		viewChanged = true;
	}else if (rotateDrag){
		if(isQuatCam()){
			//rotateCamera(rx*dt, ry*dt);
			rotateCamera(mouseMovedXPixels*.005, mouseMovedYPixels*.005);
		}else{
			//FIXME rename angleY and angleX cuz they're swapped, but careful not to 1/4 turn camera
			angleY += mouseMovedXPixels*.01;
			angleX += mouseMovedYPixels*.01;
		}
		viewChanged = true;
	}
	lastX = e.clientX;
	lastY = e.clientY;
});
canvas.addEventListener("wheel", function(e){
	e.preventDefault();
	//FIXME amount? multiple events come for single move? Mouse/pad wheels/slideAreaOnSide
	//have more precision on mac than windows.
	let movedWheel = e.deltaY < 0 ? 1 : -1;
	if(isQuatCam()){
		//moveCamera(fwdVal*moveSpd*dt, upDown*moveSpd*dt, leftRight*moveSpd*dt);
		moveCamera(movedWheel,0,0);
	}else{
		//zoom *= e.deltaY < 0 ? 1.1 : 0.9;
		zoom *= Math.exp(.1*movedWheel);
	}
	viewChanged = true;
});

var xyzInFrontOfCam = dist=>{
	return Add(camPos, VecMulScalar(calculateForwardVector(camQ),dist));
};

//var cursor3dDistanceInFrontOfCam = 12.3;
//var cursor3dDistanceInFrontOfCam = 20;
var cursor3dDistanceInFrontOfCam = 35;

//target quadray in front of camPos along the forward direction of camQ. CCP grid aligned.
var targetQ = ()=>(quadrayInFrontOfCam(cursor3dDistanceInFrontOfCam).nearestCCP());

var quadrayInFrontOfCam = dist=>{
	return Quadray.fromCartesian(xyzInFrontOfCam(dist));
};

var toggleVolumeAtQuadray = q=>{
	fillGridByFunc(q, 0, ()=>true);
};

//whatever is the selected paint tool, paints or unpaints with it
var paint = (q, paintbrush, isPaintElseUnpaint)=>{
	console.log('Paint at q='+q+' isPaintElseUnpaint='+isPaintElseUnpaint+' paintbrushKeys='+Object.keys(paintbrush));
	if(paintbrush.paintbrushNames){
		let brushes = Object.values(paintbrushes);
		let brush = brushes[randInt(brushes.length)];
		return paint(q, brush, isPaintElseUnpaint);
	}
	/*if(paintbrush.func){
		paintbrush.func(isPaintElseUnpaint);
	}*/
	if(paintbrush.mask & PB_OCT) for(let octQ of paintbrush.quads){
		if(isPaintElseUnpaint){
			addOctAtQuadray(q.add(octQ));
		}else{
			console.warn('TODO remove octahedron at quadray '+q);
		}
	}
	if(paintbrush.mask & PB_TETC) for(let tetcQ of paintbrush.quads){
		if(isPaintElseUnpaint){
			addTetCAtQuadray(q.add(tetcQ));
		}else{
			console.warn('TODO remove tetrahedronCs at quadray '+q);
		}
	}
	if(paintbrush.mask & PB_TETZ) for(let tetzQ of paintbrush.quads){
		if(isPaintElseUnpaint){
			addTetZAtQuadray(q.add(tetzQ));
		}else{
			console.warn('TODO remove tetrahedronZs at quadray '+q);
		}
	}
	if(paintbrush.mask & PB_BALL) for(let ballQ of paintbrush.quads){
		if(isPaintElseUnpaint){
			AddBall(q.add(ballQ));
		}else{
			RemBall(q.add(ballQ));
		}
	}
	//TODO what other paint tools
	//fillGridByFunc(q, 1, ()=>isPaintElseUnpaint);
	//fillGridByFunc(q, 1, ()=>true); //only does paint, not unpaint as of 2025-8-17
	//toggleVolumeAtQuadray(q); //FIXME
};

/*var toggleVolumeInFrontOfCam = dist=>{
	let q = quadrayInFrontOfCam(dist);
	console.log('toggleVolumeInFrontOfCam q='+q);
	q = q.nearestCCP();
	toggleVolumeAtQuadray(q);
};*/

//TODO this toggles not fills. add param for add vs remove vs toggle.
//centerQ can be selq or any quadray on the grid. hops is how far outward from it in key presses.
//func(quadray) => true or false, should that part of the volume be filled or not.
//TODO add isDelete param, but theres only addOctAtQuadray no remove param, and if u remove u gotta handle shared triangles between octahedrons/tetrahedrons.
var fillGridByFunc = (centerQ, hops, func)=>{
	let gridQuadrays = gridDotsNear(centerQ, hops);
	let countOctYes = 0;
	let countOctNo = 0;
	let countTetZYes = 0;
	let countTetZNo = 0;
	let countTetCYes = 0;
	let countTetCNo = 0;
	for(let q of gridQuadrays){
		if(func(q.add(toOctCenter))){
			//toggleOctAtQuadray(q); //TODO add instead of toggle?
			//if(isDelete){
			//}else{
				addOctAtQuadray(q);
			//}
			countOctYes++;
		}else{
			countOctNo++;
		}
		if(func(q.add(toTetZCenter))){
			//toggleTetZAtQuadray(q); //TODO add instead of toggle?
			addTetZAtQuadray(q);
			countTetZYes++;
		}else{
			countTetZNo++;
		}
		if(func(q.add(toTetCCenter))){
			//toggleTetCAtQuadray(q); //TODO add instead of toggle?
			addTetCAtQuadray(q);
			countTetCYes++;
		}else{
			countTetCNo++;
		}
		/*if(func(q)){ //func says its solid, so put octahedron or tetrahedron here (todo offset into center of those shapes, not corner)
			toggleOctAtQuadray(q); //TODO add instead of toggle?
			countYes++;
		}else{
			countNo++;
		}*/
	}
	return 'fillGridByFunc matched '+countOctYes+'/'+countTetZYes+'/'+countTetCYes+' of '+(countOctYes+countOctNo)+'/'+(countTetZYes+countTetZNo)+'/'+(countTetCYes+countTetCNo)+' octahedrons/tetrahedronZs/tetrahedronCs';
};

var SimKeyPress = key=>{
	if(Directions[key]){
		if(dom('directionsButtonsMoveCam').checked){
			camPos = Directions[key].add(Quadray.fromCartesian(camPos)).toCartesian();
		}else{
			//RemDot(selq);
			nextSelq = selq.add(Directions[key]);
			console.log('selq='+selq.toDetailString()+' nextSelq='+nextSelq.toDetailString());
			selq = nextSelq;
			AddDot(selq);
			AddBall(selq);
		}
	//}else if(key=='Enter'){
	//	displayCheckerboardDots = !displayCheckerboardDots;
	}else if(key=='z'){
		toggleTetZAtQuadray(selq);
	}else if(key=='x'){
		toggleOctAtQuadray(selq); //when push this button, add or remove an octahedron in quadray coords
	}else if(key=='c'){
		toggleTetCAtQuadray(selq);
	}else if(key==' '){ //all 3
		toggleTetZAtQuadray(selq);
		toggleOctAtQuadray(selq);
		toggleTetCAtQuadray(selq);
	}else if(key=='Shift'){
		displayQgridDots = !displayQgridDots;
	}else{
		console.log('Directions['+key+']='+Directions[key]);
	}
	copyWorldStateToUiControls(); //in case selq changed
};

document.addEventListener("keydown", function(e){
	if(e.target == dom('textBoxToEval')){
		return; //ignore game controls when in textarea. WARNING: if you add other things that take key presses, do this too,
	}
	Buttons[e.key] = 1;
	SimKeyPress(e.key);
});

document.addEventListener("keyup", function(e){
	delete Buttons[e.key];
});

function rotate([x, y, z]){ //3d not quadray
	let dx = x - side/2, dz = z - side/2;
	let tx = dx * Math.cos(angleY) - dz * Math.sin(angleY);
	let tz = dx * Math.sin(angleY) + dz * Math.cos(angleY);
	dx = tx; dz = tz;
	let dy = y - side/2;
	tx = dy * Math.cos(angleX) - tz * Math.sin(angleX);
	tz = dy * Math.sin(angleX) + tz * Math.cos(angleX);
	dy = tx;
	return [dx + side/2, dy + side/2, tz + side/2];
}


function inverseRotate([x, y, z]){ //3d not quadray
	// Move to origin
	let dx = x - side/2;
	let dy = y - side/2;
	let dz = z - side/2;

	// Inverse X rotation
	let ty = dy * Math.cos(-angleX) - dz * Math.sin(-angleX);
	let tz = dy * Math.sin(-angleX) + dz * Math.cos(-angleX);
	dy = ty;
	dz = tz;

	// Inverse Y rotation
	let tx = dx * Math.cos(-angleY) - dz * Math.sin(-angleY);
	tz = dx * Math.sin(-angleY) + dz * Math.cos(-angleY);
	//let tx = dx * Math.cos(angleY) + dz * Math.sin(angleY);
	//tz = -dx * Math.sin(angleY) + dz * Math.cos(angleY);
	dx = tx;

	// Translate back from origin
	return [dx + side/2, dy + side/2, tz + side/2];
}

var isQuatCam = ()=>(document.getElementById('chkQuaternionCamera').checked);

for(let x=-10; x<10; x++) for(let y=-10; y<10; y++) for(let z=-10; z<10; z++){
	let orig = [x,y,z];
	let rotated = rotate([x,y,z]);
	let rebuiltOrig = inverseRotate(rotated);
	let dist = Dist(orig,rebuiltOrig);
	if(dist > .001) Err('inverseRotate is broken, orig='+JSON.stringify(orig)+
		' rotated='+JSON.stringify(rotated)+' rebuiltOrig='+JSON.stringify(rebuiltOrig)+' dist='+dist);
}
console.log('inverseRotate tests pass');

var getCameraXYZ = ()=>{
	if(isQuatCam()){
		lastCam = [...camPos];
	}else{
		lastCam = inverseRotate([side / 2, side / 2, side / 2 - cubeSize / zoom]);
	}
	return lastCam;
};

//var offsetZ = -5; // try +5, -5, 10, -10

function project([x, y, z]){
	if(isQuatCam()){
		/*//Transform world point into camera space
		const dx = x - camPos[0];
		const dy = y - camPos[1];
		const dz = z - camPos[2];
		const local = quatRotateVec(quatInverse(camQ), [dx, dy, dz]);
		//Perspective projection
		const scale = cubeSize / (local[2] + side);
		const screenX = canvas.width / 2 + local[0] * scale;
		const screenY = canvas.height / 2 - local[1] * scale;
		return [screenX, screenY];
		*/
		const dx = x - camPos[0];
		const dy = y - camPos[1];
		const dz = z - camPos[2];
		//const dz = z - (camPos[2] + offsetZ);

		let camForward = calculateForwardVector(camQ);
		let camUp = calculateUpVector(camQ);
		let camRight = cross(camForward, camUp);
		camRight = normalize(camRight);
		//camUp = normalize(cross(camRight, camForward));

		// World point projected into camera's local axes
		let cx = dx * camRight[0] + dy * camRight[1] + dz * camRight[2];
		let cy = dx * camUp[0] + dy * camUp[1] + dz * camUp[2];
		let cz = dx * camForward[0] + dy * camForward[1] + dz * camForward[2];
		//cx *= -1;
		//cy *= -1;
		//cz *= -1;

		//const scale = cubeSize / (-cz + side);
		const scale = cubeSize / cz; //TODO avoid divide by 0
		const screenX = canvas.width / 2 + cx * scale;
		const screenY = canvas.height / 2 - cy * scale;
		return [screenX, screenY];
	}else{
		const scale = cubeSize / (z + side);
		return [offsetX + (x - side/2) * scale * zoom, offsetY - (y - side/2) * scale * zoom];
	}
}

//how far forward/backward is it in current view. Call this on camPos to get 0 (except roundoff).
function dotProdOfXYZAlongCamForward([x, y, z]){
	let dx = x - camPos[0];
	let dy = y - camPos[1];
	let dz = z - camPos[2];
	let camForward = calculateForwardVector(camQ);
	return dx * camForward[0] + dy * camForward[1] + dz * camForward[2];
}

//p1, p3, and p3 are each a [x,y,z]. Color is like '#aabbc9' or 'blue'.
//Draw any 3d TriZngle you want anywhere, and it will be viewable by affine transformed camera
//controlled by mouse left button rotates and right button moves and wheel zooms.
//Octahedrons and (TODO) tetrahedrons are made this way.
function drawTriangle(p1, p2, p3, color){
	let a, b, c;
	if(isQuatCam()){
		a = project(p1); //[screenX,screenY]
		b = project(p2);
		c = project(p3);
	}else{
		p1 = ScaleGrid(p1);
		p2 = ScaleGrid(p2);
		p3 = ScaleGrid(p3);
		a = project(rotate(p1)); //[screenX,screenY]
		b = project(rotate(p2));
		c = project(rotate(p3));
	}
	
	let mid = Ave3(p1,p2,p3); //[x,y,z]
	let dot = dotProdOfXYZAlongCamForward(mid);
	if(dot < drawDistanceMin || drawDistanceMax < dot){
		return;
	}
	
	ctx.beginPath();
	ctx.moveTo(...a);
	ctx.lineTo(...b);
	ctx.lineTo(...c);
	ctx.closePath();
	ctx.fillStyle = color;
	ctx.fill();
	ctx.strokeStyle = '#000';
	ctx.stroke();
	if(displayDotDistances){
		ctx.fillText('dot='+dot, a[0], a[1]);
	}
}

//3d not quadray.
//updated in getCameraXYZ. Used for displaying 3d points as
//tiny circles of varying radius so you can see how far away they are.
var lastCam = [0,0,0];

//Add this to the main corner quadray of the octahedron to get the octahedron's center
const toOctCenter = quadrayAve(oct6CornersAtQuadray(Q(0,0,0,0)));
const toTetZCenter = quadrayAve(TriZ4CornersAtQuadray(Q(0,0,0,0))); //for the z tetrahedron
const toTetCCenter = quadrayAve(TriX4CornersAtQuadray(Q(0,0,0,0))); //for the c tetrahedron

var sortQuadrayTrianglesList = ()=>{ //the quadray kind of Triangles, not the 3d kind
	let view = getCameraXYZ();
	/*let scorer = tri=>{
		//FIXME this is 3d code, but only have quadrays: return -Dist(view,Ave3(tri[0],tri[1],tri[2]));
	}*/
	let scorer;
	if(isQuatCam()){
		/*scorer = tri => {
			let a = UnscaleGrid(tri.e.toCartesian());
			let b = UnscaleGrid(tri.f.toCartesian());
			let c = UnscaleGrid(tri.g.toCartesian());
			let mid = Ave3(a, b, c);

			let dx = mid[0] - camPos[0];
			let dy = mid[1] - camPos[1];
			let dz = mid[2] - camPos[2];

			// Rotate into camera-local frame
			let [_, __, camZ] = quatRotateVec(camQ, [dx, dy, dz]);

			return -camZ; // bigger Z = farther away = draw first
		};*/
		scorer = tri => {
			let a = tri.e.toCartesian();
			let b = tri.f.toCartesian();
			let c = tri.g.toCartesian();
			return -Dist(view, Ave3(a, b, c));
		};
	}else{
		scorer = tri => {
			let a = UnscaleGrid(tri.e.toCartesian());
			let b = UnscaleGrid(tri.f.toCartesian());
			let c = UnscaleGrid(tri.g.toCartesian());
			return -Dist(view, Ave3(a, b, c));
		};
	}
	let gameTrisList = Object.values(gameTris);
	gameTrisList.sort((a,b)=>Math.sign(scorer(a)-scorer(b)));
	gameTris = {};
	for(let tri of gameTrisList) AddGameTri(tri); //into gameTris. js {} gives keys in order they were first added, keeping sort
};

/*AddQgridDot(selq);
for(let depth=1; depth<=qgridBootDepth; depth++){
	expandQgridDotsOneDeeper();
}*/

let theGridDots = gridDotsNear(selq, qgridBootDepth);
for(let q of theGridDots){
	AddQgridDot(q);
}

var gridChanged = false;
var viewChanged = false;

/*var toggleOctahedronAt = index=>{
	gridChanged = true;
	grid[index] ^= (BIT_OCT | (BIT_TRIS*255)); //1 octahedron bit and 8 face bits
};*/

var updateIfGridChanged = ()=>{
	if(gridChanged || viewChanged){
		sortQuadrayTrianglesList();
		copyWorldStateToUiControls();
		gridChanged = false;
		viewChanged = false;
	}
};

//draw a 3d dot (or circle if give radius) of chosen [x,y,z] and color
var paintXYZColor = (xyz, color, optionalRadius)=>{
	const [px, py] = isQuatCam() ? project(xyz) : project(rotate(ScaleGrid(xyz)));
	
	let dot = dotProdOfXYZAlongCamForward(xyz);
	if(dot < drawDistanceMin || drawDistanceMax < dot){
		return;
	}
	
	ctx.fillStyle = color;
	ctx.beginPath();
	let radius = optionalRadius || 2;
	if(varyPointSizeByDistanceToCamera){
		let distanceToCam = Dist(xyz,lastCam);
		radius = 1+3*(.5+.5*Math.sin(distanceToCam*20));
	}
	ctx.arc(px, py, radius, 0, 2 * Math.PI);
	ctx.fill();
};

var paintCircle2d = (screenX, screenY, radius, color, isFillElseOutline)=>{
	paintOval2d(screenX, screenY, radius, 0, 0, radius, color, isFillElseOutline);
	/*ctx.beginPath();
	ctx.arc(screenX, screenY, radius, 0, Math.PI*2);
	if(isFillElseOutline){
		ctx.fillStyle = color;
		ctx.fill();
	}else{
		ctx.lineWidth = 2; //circle outline thickness
		ctx.strokeStyle = color;
		ctx.stroke();
	}*/
};

var paintOval2d = (centerX, centerY, aX, aY, bX, bY, color, isFillElseOutline)=>{
	ctx.save();
	ctx.translate(centerX, centerY);
	ctx.transform(aX, aY, bX, bY, 0, 0);	 // columns are a, b

	ctx.beginPath();
	ctx.arc(0, 0, 1, 0, Math.PI*2);

	if(isFillElseOutline){
	ctx.fillStyle = color;
	ctx.fill();
	}else{
	const det = aX*bY - aY*bX;			 // area scale (Jacobian)
	const s = Math.sqrt(Math.max(1e-9, Math.abs(det)));
	ctx.lineWidth = 2 / s;				 // roughly constant screen stroke
	ctx.strokeStyle = color;
	ctx.stroke();
	}
	ctx.restore();
};


/*var paintBall=(xyz,rWorld=1,color)=>{
	if(!isQuatCam()){
		return;
	}
	const ctr=project(xyz);				// centre in screen px
	const edge=project([xyz[0]+rWorld,xyz[1],xyz[2]]);	// 1-unit offset → px radius
	const pr=Math.hypot(edge[0]-ctr[0],edge[1]-ctr[1]);
	let dot=dotProdOfXYZAlongCamForward(xyz);
	if(dot<drawDistanceMin||drawDistanceMax<dot)return;
	paintCircleScreen(ctr[0],ctr[1],pr,color);	// outline only
};*/
/*var paintBall=(xyz, radius, color)=>{
	if(!isQuatCam()){
		Err('circles only happen if isQuatCam(). The old display code will be removed someday.');
	}
	const ctr = project(xyz);
	const edge = project([xyz[0]+radius,xyz[1],xyz[2]]); //offset in 3d by 1 radius
	const radius2d = Math.hypot(edge[0]-ctr[0],edge[1]-ctr[1]);	

	let dot = dotProdOfXYZAlongCamForward(xyz);
	if(dot<drawDistanceMin || drawDistanceMax<dot){
		return;				// culled by Z-distance limits
	}
	paintCircle2d(ctr[0],ctr[1],radius2d,color);
};*/
/*var paintBall = (xyz, radius, color, isFillElseOutline) => {
	if(!isQuatCam())	return;						// circles only in quat-cam

	//project centre once
	const ctr = project(xyz);

	//camera-space depth (distance along forward axis)
	const dot = dotProdOfXYZAlongCamForward(xyz);
	if(dot < drawDistanceMin || drawDistanceMax < dot || dot === 0)	return;

	//perspective: px-radius = rWorld * (cubeSize / dot)
	const pr = radius * cubeSize / dot;

	paintCircle2d(ctr[0], ctr[1], pr, color, isFillElseOutline);
};*/
// --- paintBall: simplified call path ---
var paintBall = (xyz, radius, color, isFillElseOutline, isConePlaneIntersection)=>{
	if(!isQuatCam()) return;

	// depth for culling + legacy radius
	const cz = dotProdOfXYZAlongCamForward(xyz);
	if(cz < drawDistanceMin || drawDistanceMax < cz || cz === 0) return;
	
	let doConePlane = isConePlaneIntersection;
	const affine = conePlaneIntersection(xyz, radius);
	let err = false;
	if(!affine){
		err = true;
		doConePlane = false; //didnt find intersection, maybe it crossed both ends of cone or not ellipse.
	}
	if(doConePlane){
		// either a true ellipse, or the "inside sphere" big fill case
		const [centerX, centerY, aX, aY, bX, bY] = affine;
		paintOval2d(centerX, centerY, aX, aY, bX, bY, color, isFillElseOutline);		
	}else{
		if(err) color = 'red';
		const ctr = project(xyz);
		const pr	= radius * cubeSize / cz;
		paintCircle2d(ctr[0], ctr[1], pr, color, isFillElseOutline);
	}
};

//by GPT5. not sure if this works, todo test.
// --- exact cone∩plane silhouette as a 2D affine ---
// Returns [centerX, centerY, aX, aY, bX, bY] in *screen pixels*, or null on degenerate cases.
/*var conePlaneIntersection = (xyz, radius)=>{
	// camera basis
	const dx = xyz[0]-camPos[0], dy = xyz[1]-camPos[1], dz = xyz[2]-camPos[2];
	let f = calculateForwardVector(camQ);
	let u = calculateUpVector(camQ);
	let r = cross(f, u); r = normalize(r);
	u = normalize(cross(r, f));

	// sphere center in camera space
	const cx = dx*r[0] + dy*r[1] + dz*r[2];
	const cy = dx*u[0] + dy*u[1] + dz*u[2];
	const cz = dx*f[0] + dy*f[1] + dz*f[2];

	// clip / reject
	if(cz <= 0 || cz < drawDistanceMin || drawDistanceMax < cz) return null;

	const d = cubeSize;				 // image plane z = d, must match project()
	const L = Math.hypot(cx, cy, cz); // ||C||
	if(L < 1e-9) return null;

	// inside sphere → huge fill (signal caller to draw circle big)
	if(radius >= L*0.999999) return [ ...project(xyz), 1e6, 0, 0, 1e6 ];

	// cone parameters
	const s = radius / L;
	const cos2 = Math.max(0, 1 - s*s);
	const ux = cx/L, uy = cy/L, uz = cz/L;

	// conic: A x² + B xy + C y² + D x + E y + F = 0 on z=d
	const A = ux*ux - cos2;
	const B = 2*ux*uy;
	const C = uy*uy - cos2;
	const D = 2*d*ux*uz;
	const E = 2*d*uy*uz;
	const F = d*d*(uz*uz - cos2);

	// ellipse center
	const denom = 4*A*C - B*B;
	if(Math.abs(denom) < 1e-12) return null;
	const x0 = (B*E - 2*C*D) / denom;
	const y0 = (B*D - 2*A*E) / denom;

	// translate to center: uᵀ Q u = k
	const Fc = (A*x0*x0 + B*x0*y0 + C*y0*y0 + D*x0 + E*y0 + F);
	const k	= -Fc;
	if(!(k > 0)) return null;

	// Q SPD: [[A, B/2],[B/2, C]] ; Cholesky Q = L Lᵀ
	const l11 = Math.sqrt(Math.max(1e-18, A));
	const l21 = (B*0.5) / l11;
	const cRem = C - l21*l21;
	if(!(cRem > 0)) return null;
	const l22 = Math.sqrt(cRem);

	// (Lᵀ)⁻¹ for Lᵀ = [[l11, l21],[0, l22]]
	const invLT11 = 1 / l11;
	const invLT12 = -l21 / (l11*l22);
	const invLT21 = 0;
	const invLT22 = 1 / l22;

	// plane transform T_plane = √k · (Lᵀ)⁻¹	(x-right, y-up)
	const sK = Math.sqrt(k);
	const t11 = sK * invLT11;
	const t12 = sK * invLT12;
	const t21 = sK * invLT21;	// = 0
	const t22 = sK * invLT22;

	// plane → screen: Y flip; screen center
	const centerX = canvas.width/2	+ x0;
	const centerY = canvas.height/2 - y0;
	const aX =	t11;
	const aY = -t21;	 // 0 but keep form
	const bX =	t12;
	const bY = -t22;

	// quick sanity: finite, non-NaN
	if(!isFinite(centerX+centerY+aX+aY+bX+bY)) return null;

	return [centerX, centerY, aX, aY, bX, bY];
};*/
// --- exact cone∩plane silhouette as a 2D affine ---
// Returns [centerX, centerY, aX, aY, bX, bY] in screen pixels, or null if not drawable.
var conePlaneIntersection = (xyz, radius)=>{
	// camera basis
	const dx = xyz[0]-camPos[0], dy = xyz[1]-camPos[1], dz = xyz[2]-camPos[2];
	let f = calculateForwardVector(camQ);
	let u = calculateUpVector(camQ);
	let r = cross(f, u); r = normalize(r);
	u = normalize(cross(r, f));

	// sphere center in camera space
	const cx = dx*r[0] + dy*r[1] + dz*r[2];
	const cy = dx*u[0] + dy*u[1] + dz*u[2];
	const cz = dx*f[0] + dy*f[1] + dz*f[2];

	// clip / reject
	if (cz <= 0 || cz < drawDistanceMin || drawDistanceMax < cz) return null;

	const d = cubeSize;				 // must match project()
	const L = Math.hypot(cx, cy, cz); // ||C||
	if (L < 1e-9) return null;

	// camera inside the sphere → huge fill
	if (radius >= L*0.999999){
	const [px,py] = project(xyz);
	return [px, py, 1e6, 0, 0, 1e6];
	}

	// tangent-cone parameters
	const s = radius / L;
	const cos2 = Math.max(0, 1 - s*s);
	const ux = cx/L, uy = cy/L, uz = cz/L;

	// conic on plane z=d: A x² + B xy + C y² + D x + E y + F = 0
	const A = ux*ux - cos2;
	const B = 2*ux*uy;
	const C = uy*uy - cos2;
	const D = 2*d*ux*uz;
	const E = 2*d*uy*uz;
	const F = d*d*(uz*uz - cos2);

	// center: solve [2A B; B 2C] [x0;y0] = -[D;E] (use gentle regularization if near-singular)
	let det = 4*A*C - B*B;
	if (!isFinite(det)) det = 0;
	if (Math.abs(det) < 1e-9) det = (det >= 0 ? 1 : -1) * 1e-9; // keep sign to avoid flipping the center wildly
	const x0 = (B*E - 2*C*D) / det;
	const y0 = (B*D - 2*A*E) / det;

	// translate to center → uᵀ Q u = k
	const Fc = (A*x0*x0 + B*x0*y0 + C*y0*y0 + D*x0 + E*y0 + F);
	let k = -Fc;						 // for an ellipse, k and the eigenvalues share the same sign

	// eigen-decompose Q (no Cholesky; works for either sign)
	const trace = A + C;
	const diff	= A - C;
	const disc	= Math.hypot(diff, B);		 // sqrt((A-C)^2 + B^2)
	let	 lam1	= (trace + disc)/2;
	let	 lam2	= (trace - disc)/2;

	if (k === 0) return null;

	// ensure radii² = k/λ are positive; if not, flip both sides
	if ((k/lam1) <= 0 || (k/lam2) <= 0){
	k = -k; lam1 = -lam1; lam2 = -lam2;
	if ((k/lam1) <= 0 || (k/lam2) <= 0) return null; // truly non-elliptic (shouldn't happen for visible spheres)
	}

	const t1 = Math.sqrt(k/lam1);	 // semi-axis length along eigenvector 1 (plane coords, y-up)
	const t2 = Math.sqrt(k/lam2);	 // semi-axis length along eigenvector 2

	// rotation angle of principal axes
	const phi = 0.5 * Math.atan2(B, (A - C));
	const cs = Math.cos(phi), sn = Math.sin(phi);

	// plane → screen: y-flip and add screen center
	const centerX = canvas.width/2	+ x0;
	const centerY = canvas.height/2 - y0;

	// columns of T_screen = R_flip * R(phi) * diag(t1, t2)
	const aX =	cs * t1;
	const aY = -sn * t1;
	const bX = -sn * t2;
	const bY = -cs * t2;

	if (!isFinite(centerX+centerY+aX+aY+bX+bY)) return null;
	return [centerX, centerY, aX, aY, bX, bY];
};



function draw(){
	let dt = 1/60; //TODO measure and clamp it
	
	updateFromGamepad(dt);
	updateFromHoldingKeyboardButtons(dt);
	getCameraXYZ(); //to update lastCam. xyz not quadray.

	//selq and TriZngle corners and octahedron corners and tetrahedron corners are all quadrays,
	//converted to xyz at last moment for display.
	selq.color = randColor(); //make it flash

	updateIfGridChanged();
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	
	let isQuat = isQuatCam();
	
	//--- collect, sort, draw farthest→nearest ---
	let drawables=[];
	if (dom('isCcpBallGrid').checked){
		for (const q of ccp.surfaceQuadrays()){
			// pass world coords once; Drawable('ball') uses xyz directly
			//drawables.push(new Drawable('ball', q, q.toCartesian()));
			const [i,j,k] = ccp.toASD(q);
			//let neighbors = ccp.neighborCount(i,j,k);
			//const shade   = ccp.shadeForNeighborCount(neighbors);
			//let color = neighbors==12 ? '#808080' : null; //gray if its inside (not surface)
			//let color = neighbors==12 ? '#ff0000' : '#0000ff'; //red if inside, blue if surface surface)
			let color = null;
			//console.log('neighbors='+neighbors+' color='+color);
			drawables.push(new Drawable('ball', q, q.toCartesian(), color));
		}
	}
	if(isQuatCam()){
		for(const q of Object.values(QBalls))
			drawables.push(new Drawable('ball',q,q.toCartesian()));
	}
	for(const tri of Object.values(gameTris)){
		let mid=Ave3(tri.e.toCartesian(),tri.f.toCartesian(),tri.g.toCartesian());
		drawables.push(new Drawable('tri',tri,mid));
	}
	for(const q of Object.values(QDots)){
		drawables.push(new Drawable('QDot', q, q.toCartesian()));
	}
	if(displayQgridDots) for(const q of Object.values(QGridDots)){
		if(!QDots[q]){ //display QDots/selfColoredAnyColor over QGridDots/blue
			drawables.push(new Drawable('QGridDot', q, q.toCartesian()));
		}
	}
	drawables.sort((a,b)=>(b.depth-a.depth));

	for(const d of drawables){
		d.draw();
	}
	
	let targ = targetQ(); //in front of camera, grid aligned.
	let fill = false; //circle/oval outline
	let isConePlaneIntersection = dom('isConePlaneIntersection').checked;
	let brush = selectedPaintbrush();
	if(brush.balls){ //display white circles of actual shape of paintbrush
		for(let ballQ of brush.balls){
			paintBall(targ.add(ballQ).toCartesian(), ballRadius, '#ffffff', fill, isConePlaneIntersection);
		}
	}else{ //display others as: paint white circle 3d cursor in front of cam
		paintBall(targ.toCartesian(), ballRadius, '#ffffff', fill, isConePlaneIntersection);
	}

	
	/*
	//Draw quadray-based Triangles
	for(const tri of Object.values(gameTris)){
		drawTriangle(
			//UnscaleGrid cuz theres 2 coordinate systems that ive aligned here by scaling one by ROOT2. [x,y,z] vs quadray.
			//The 2 coordinate systems were aligned in QuadGrid.html but the 3d one mostly removed (except camera) in QuadGrid2.html.
			isQuat ? tri.e.toCartesian() : UnscaleGrid(tri.e.toCartesian()),
			isQuat ? tri.f.toCartesian() : UnscaleGrid(tri.f.toCartesian()),
			isQuat ? tri.g.toCartesian() : UnscaleGrid(tri.g.toCartesian()),
			tri.color
		);
	}
	
	if(isQuatCam()){
		for(const q of Object.values(QDots)){ //paint circles
			let fill = false;
			//let fill = true;
			let radius = 1;
			paintBall(q.toCartesian(), radius, q.color, fill);	//throws if !isQuatCam()
			//let radius = 1; //cuz xyz length of CoreDirections is each 2.
			//paintXYZColor(q.toCartesian(), q.color, radius);
		}
	}

	if(displayQgridDots) for(const q of Object.values(QGridDots)){
		paintXYZColor(isQuat ? q.toCartesian() : UnscaleGrid(q.toCartesian()), 'blue');
	}
	
	for(const q of Object.values(QDots)){
		paintXYZColor(isQuat ? q.toCartesian() : UnscaleGrid(q.toCartesian()), q.color);
	}
	*/
	
	requestAnimationFrame(draw);
}
requestAnimationFrame(draw);

var SimKeyPresses = str=>{
	console.log('SimKeyPresses str='+str);
	for(let ch of str){
		SimKeyPress(ch);
	}
};

var dom = id=>document.getElementById(id);

var quicksave = function(name){
	console.log('quicksave '+name);
	let json = StateJson();
	console.log(json);
	localStorage.setItem('quadcraft.quicksave.'+name, json);
};

var quickload = function(name){
	console.log('quickload '+name);
	let json = localStorage.getItem('quadcraft.quicksave.'+name);
	console.log(json);
	if(json){
		LoadJson(json);
	}
};

var deleteCookies = ()=>{
	for (let i = 0; i < localStorage.length; i++) {
		let key = localStorage.key(i);
		if (key.startsWith('quadcraft.quicksave.')){
			localStorage.removeItem(key);
			console.log('Deleted localStorage cookie: '+key);
			i--; // Adjust index since keys shift after removal
		}
	}
};

var saveFile = (fileName, contentType, text)=>{
	var blob = new Blob([text], {type: contentType});
	var elem = window.document.createElement('a');
	elem.href = window.URL.createObjectURL(blob);
	elem.download = fileName;
	document.body.appendChild(elem);
	elem.click();
	document.body.removeChild(elem);
};

//load state as json
var LoadJson = json=>LoadMap(JSON.parse(json));

//get state as json
var StateJson = ()=>JSON.stringify(StateMap());

var ClearShapes = ()=>{
	for(let k in gameTris){
		delete gameTris[k];
	}
	for(let k in QDots){
		delete QDots[k];
	}
	for(let key in grid){
		grid[key].clear(); //Set of quadray
	}
	ccp.clear();
	gridChanged=true;
};

var StateMap = ()=>({
	type: 'quadcraft_quadraygrid4_state',
	selq: [selq.a, selq.b, selq.c, selq.d],
	camera: { //used if !isCamQuat()
		offsetX,
		offsetY,
		zoom,
		angleX,
		angleY
	},
	camPos: [...camPos], //[x,y,z], used if isCamQuat()
	camQ: [...camQ], //quaternion list size 4, used if isCamQuat()
	textBoxToEval: dom('textBoxToEval').value,
	grid: gridToMap(grid),
	ccp: ccp.save(),
});

var LoadMap = map=>{
	if(map.type !== 'quadcraft_quadraygrid4_state') return;
	
	ClearShapes();

	selq = Q(...map.selq);
	if(map.camera){
		({offsetX, offsetY, zoom, angleX, angleY} = map.camera);
	}
	if(map.camPos){
		camPos = [...(map.camPos)]; //copy
	}
	if(map.camQ){
		camQ = [...(map.camQ)]; //copy
	}

	if(!map.grid) Err('No map.grid');
	//Example: "grid":{"oct":[[1,2,0,1],[2,4,0,2],[3,6,0,3],[4,8,0,4],[4,9,0,3],[4,10,0,2],[4,11,0,1],[4,12,0,0],[4,11,1,0],[4,10,2,0],[4,9,3,0],[4,8,4,0],[3,6,3,0]],"tetZ":[[1,2,0,1],[2,4,0,2],[3,6,0,3],[4,8,0,4],[4,9,0,3],[4,10,0,2],[4,11,0,1],[4,12,0,0],[4,11,1,0],[4,10,2,0],[4,9,3,0],[4,8,4,0],[3,6,3,0]],"tetC":[[1,2,0,1],[2,4,0,2],[3,6,0,3],[4,8,0,4],[4,9,0,3],[4,10,0,2],[4,11,0,1],[4,12,0,0],[4,11,1,0],[4,10,2,0],[4,9,3,0],[4,8,4,0],[3,6,3,0]]
	for(let abcd of map.grid.oct){
		let quadray = Q(...abcd);
		toggleOctAtQuadray(quadray);
	}
	for(let abcd of map.grid.tetZ){
		let quadray = Q(...abcd);
		toggleTetZAtQuadray(quadray);
	}
	for(let abcd of map.grid.tetC){
		let quadray = Q(...abcd);
		toggleTetCAtQuadray(quadray);
	}
	/*gameTris = {};
	for(let tri of map.gameTris){
		let e = Q(...tri.e);
		let f = Q(...tri.f);
		let g = Q(...tri.g);
		let t = T(e, f, g);
		t.color = tri.color;
		AddGameTri(t);
	}*/
	
	if(map.ccp){
		ccp.load(map.ccp);
	}
	
	if(map.textBoxToEval !== undefined){
		dom('textBoxToEval').value = map.textBoxToEval;
	}

	copyWorldStateToUiControls();
	gridChanged = true;
};

var openFileInputClicked = event=>{
	console.log('openFileInputClicked, event='+event);
	const file = event.target.files[0];
	if (!file) return;
	const reader = new FileReader();
	reader.onload = e => {
		const json = e.target.result;
		LoadJson(json); // same as quickload
	};
	reader.readAsText(file);
};



var copyWorldStateToUiControls = ()=>{
	dom('numOffsetX').value = offsetX;
	dom('numOffsetY').value = offsetY;
	dom('numZoom').value = zoom;
	dom('numAngleX').value = angleX;
	dom('numAngleY').value = angleY;
	dom('labelUnderUiControls').innerHTML = 'selq='+selq;
	dom('camQuadLabel').innerHTML = 'camPos='+JSON.stringify(camPos)+'<br>camQ='+JSON.stringify(camQ)+'<br>navigator.getGamepads()[0]='+navigator.getGamepads()[0];
};

var copyUiControlsToWorldState = ()=>{
	offsetX = dom('numOffsetX').valueAsNumber;
	offsetY = dom('numOffsetY').valueAsNumber;
	zoom = dom('numZoom').valueAsNumber;
	angleX = dom('numAngleX').valueAsNumber;
	angleY = dom('numAngleY').valueAsNumber;
	viewChanged = true;
};

const timeOffset_ = performance.timing.navigationStart;
//UTC seconds with fraction. More precise than Date.now()*.001. Chrome seems to have 4 digits after decimal point, and brave and firefox 3 digits.
const time = ()=>((timeOffset_+performance.now())*.001);

var onloadHappened = false;

var onload = ()=>{
	if(!onloadHappened){
		onloadHappened = true;
		populatePaintbrushSelect();
		copyWorldStateToUiControls();
		paintXYZColor([0,0,1],randColor());
	}
};

window.onload = onload;
setTimeout(onload, .5); //in case its in an iframe that blocks window.onload


function quatInverse([x, y, z, w]){ //GPT4o
	return [-x, -y, -z, w];
}

function quatRotateVec(q, v){ //GPT4o
	const [x, y, z] = v;
	const [qx, qy, qz, qw] = q;

	// Quaternion-vector multiplication (q * v * q^-1)
	const uvx = qw * x + qy * z - qz * y;
	const uvy = qw * y + qz * x - qx * z;
	const uvz = qw * z + qx * y - qy * x;

	const uuvx = qy * uvz - qz * uvy;
	const uuvy = qz * uvx - qx * uvz;
	const uuvz = qx * uvy - qy * uvx;

	return [
		x + 2 * (uvx * qw + uuvx),
		y + 2 * (uvy * qw + uuvy),
		z + 2 * (uvz * qw + uuvz)
	];
}

//START: 2025-7-28+ copying some camera/gamepad code from bellsack236 under MIT license:
//https://github.com/benrayfield/jsutils/blob/master/src/bellsack/bellsack236_moreStableTerrainReshapingCuzBallsAndTerrainHeldNearStartingPositionsBySprings.html

//let camPos=[0,0,5];
let camPos = [0,0,-5];
//let camPos=[0,0,0];
//let camPos=[0,0,-12]; //far back so can see balls 2025-7-17
let camQ = [0,0,0,1];

//var moveSpd = 8.0; //speed of movement by gamepad joysticks/analogTriggers AND mouse when right button held
var moveSpd = 15;
const secondMoveSpeedMul = .007; //if isQuatCam() then use moveSpd*secondMoveSpeedMul as ratio between them

//var turnSpd = 2;
var turnSpd = .8;
//var turnSpd = .6;

var selectedPaintbrush = ()=>{
	return paintbrushes[selPaintbrushName()];
};

var paintOrUnpaint = isPaint=>{
	paint(targetQ(), selectedPaintbrush(), isPaint);
};

function updateFromGamepad(dt){
	//console.log("updateFromGamepad", navigator.getGamepads());
	let gps= navigator.getGamepads();
	if(!gps) return;
	let gp= gps[0];
	if(!gp) return;
	let lx= gp.axes[0], ly= gp.axes[1];
	let rx= gp.axes[2], ry= gp.axes[3];
	const dead= 0.06;
	//const dead= 0; //FIXME
	let lLen= Math.hypot(lx,ly);
	if(lLen>dead){
		let leftover= lLen- dead;
		lx*= leftover/lLen;
		ly*= leftover/lLen;
	}else{ lx=0; ly=0; }
	let rLen= Math.hypot(rx,ry);
	if(rLen>dead){
		let leftover2= rLen- dead;
		rx*= leftover2/rLen;
		ry*= leftover2/rLen;
	}else{ rx=0; ry=0; }
	ry*=-1;
	rx *= turnSpd;
	ry *= turnSpd;
	rotateCamera(rx*dt, ry*dt);

	let fwdVal= gp.buttons[7]?.value - gp.buttons[6]?.value;
	let upDown= -ly;
	let leftRight= lx;
	//let moveSpd=2.0;
	//let moveSpd=.8;
	//camPos[0]+= (fwd[0]*fwdVal + upv[0]*upDown + rig[0]*leftRight)* moveSpd* dt;
	//camPos[1]+= (fwd[1]*fwdVal + upv[1]*upDown + rig[1]*leftRight)* moveSpd* dt;
	//camPos[2]+= (fwd[2]*fwdVal + upv[2]*upDown + rig[2]*leftRight)* moveSpd* dt;
	moveCamera(fwdVal*moveSpd*dt, upDown*moveSpd*dt, leftRight*moveSpd*dt);
	
	let buttonLb = gp.buttons[4].value; //0 or 1
	let buttonRb = gp.buttons[5].value; //0 or 1
	//if(buttonLb || buttonRb){
		//toggleVolumeInFrontOfCam(12.3);
	//}
	if(buttonLb ^ buttonRb){
		paintOrUnpaint(buttonRb); //buttonRb paints, buttonLb unpaints
	}
	
	//viewChanged = true; //TODO only if changed camPos or camQ
}

function updateFromHoldingKeyboardButtons(dt){
	//console.log("Buttons = "+JSON.stringify(Buttons));
	let speed = 2.1;
	let mul = speed*dt;
	/*let fwd = calculateForwardVector(camQ);
	let upv = calculateUpVector(camQ);
	let rig = normalize(cross(fwd, upv));
	let sumXYZ = [0,0,0];
	//if(Buttons.ArrowUp) sumXYZ[0] +=
	if(Buttons.ArrowUp) sumXYZ += VecMulScalar(fwd,speed);
	if(Buttons.ArrowDown) sumXYZ -= VecMulScalar(fwd,speed);
	if(Buttons.ArrowRight) sumXYZ += VecMulScalar(rig,speed);
	if(Buttons.ArrowLeft) sumXYZ -= VecMulScalar(rig,speed);
	if(Buttons.PageUp) sumXYZ += VecMulScalar(upv,speed);
	if(Buttons.PageDown) sumXYZ -= VecMulScalar(upv,speed);
	*/
	if(Buttons['`'] || Buttons['1']){
		paintOrUnpaint(Buttons['1']); //` unpaints, 1 paints. also has gamepad controls.
	}
	let forwardBackward = ((Buttons.Control ? 1 : 0)-(Buttons.Insert ? 1 : 0))*mul;
	let upDown = ((Buttons.ArrowUp ? 1 : 0)-(Buttons.ArrowDown ? 1 : 0))*mul;
	let leftRight = ((Buttons.ArrowRight ? 1 : 0)-(Buttons.ArrowLeft ? 1 : 0))*mul;
	moveCamera(forwardBackward, upDown, leftRight);
}

function moveCamera(forwardBackward, upDown, leftRight){ //does not deal with deadZone in joystick dt. TODO make moveCamera and rotateCamera consistent with eachother.
	if(forwardBackward || upDown || leftRight){
		let fwd= calculateForwardVector(camQ);
		let upv= calculateUpVector(camQ);
		let rig= cross(fwd, upv); rig= normalize(rig);
		upv = normalize(cross(rig, fwd));
		camPos[0] += (fwd[0]*forwardBackward + upv[0]*upDown + rig[0]*leftRight);
		camPos[1] += (fwd[1]*forwardBackward + upv[1]*upDown + rig[1]*leftRight);
		camPos[2] += (fwd[2]*forwardBackward + upv[2]*upDown + rig[2]*leftRight);
		viewChanged = true; //TODO only if changed camPos or camQ
	}
}

function rotateCamera(rx, ry){ //does not deal with deadZone in joystick
	if(rx || ry){
		//const threshold= 0.001;
		let fwd= calculateForwardVector(camQ);
		let upv= calculateUpVector(camQ);
		let rig= cross(fwd, upv); rig= normalize(rig);
		upv = normalize(cross(rig, fwd));

		let combined=[0,0,0,1];
		//if(Math.abs(rx)> threshold){
			//let yawAngle= -rx*2.0* dt;
			let yawAngle= -rx*2.0;
			let yawQ= createQuaternion(upv,yawAngle);
			combined= multiplyQuaternions(yawQ,combined);
		//}
		//if(Math.abs(ry)> threshold){
			//let pitchAngle= -ry*2.0* dt;
			let pitchAngle= -ry*2.0;
			let pitchQ= createQuaternion(rig,pitchAngle);
			combined= multiplyQuaternions(combined,pitchQ);
		//}
		camQ = multiplyQuaternions(combined, camQ);
		camQ = normalizeQuaternion(camQ);
		viewChanged = true;
	}
}

function calculateForwardVector(q){
	const[x,y,z,w]=q;
	const xx= 2.0*(x*z+ w*y);
	const yy= 2.0*(y*z- w*x);
	const zz= 1.0- 2.0*(x*x+ y*y);
	const ln= Math.hypot(xx,yy,zz);
	if(ln<1e-9) return [0,0,1];
	return [xx/ln, yy/ln, zz/ln];
}

function calculateUpVector(q){
	const[x,y,z,w]=q;
	const xx= 2.0*( x*y- w*z );
	const yy= 1.0- 2.0*( x*x+ z*z );
	const zz= 2.0*( y*z+ w*x );
	const ln= Math.hypot(xx,yy,zz);
	if(ln<1e-9) return [0,1,0];
	return [xx/ln, yy/ln, zz/ln];
}

function cross(a,b){
	return [
		a[1]*b[2]-a[2]*b[1],
		a[2]*b[0]-a[0]*b[2],
		a[0]*b[1]-a[1]*b[0]
	];
}

function normalize(v){
	const ln= Math.hypot(v[0],v[1],v[2]);
	if(ln<1e-9) return [0,0,0];
	return [v[0]/ln, v[1]/ln, v[2]/ln];
}

function multiplyQuaternions(q1,q2){
	const[x1,y1,z1,w1]=q1;
	const[x2,y2,z2,w2]=q2;
	return [
		w1*x2 + x1*w2 + y1*z2 - z1*y2,
		w1*y2 - x1*z2 + y1*w2 + z1*x2,
		w1*z2 + x1*y2 - y1*x2 + z1*w2,
		w1*w2 - x1*x2 - y1*y2 - z1*z2
	];
}

function createQuaternion(axis,angle){
	const ha= angle*0.5;
	const s = Math.sin(ha);
	return [ axis[0]*s, axis[1]*s, axis[2]*s, Math.cos(ha)];
}

function normalizeQuaternion(q){
	const ln= Math.hypot(q[0],q[1],q[2],q[3]);
	if(ln<1e-9) return [0,0,0,1];
	return [q[0]/ln, q[1]/ln, q[2]/ln, q[3]/ln];
}

function populatePaintbrushSelect(){
	const sel = document.getElementById('paintbrushSelect');
	if(!sel) return;						 // HTML not yet in DOM

	// add one <option> per paintbrush key
	Object.keys(paintbrushes).forEach(name=>{
		const opt = document.createElement('option');
		opt.value = name;
		opt.textContent = name;
		sel.appendChild(opt);
	});

	// highlight current choice
	sel.value = selPaintbrushName(); //get default name once, otherwise its circular-logic
}

//END: 2025-7-28+ copying some camera/gamepad code from bellsack236 under MIT license.

window.addEventListener("gamepadconnected", e => {
	console.log("CONNECTED:", e.gamepad);
});

window.addEventListener("gamepaddisconnected", e => {
	console.log("DISCONNECTED:", e.gamepad);
});


//made by Ben F Rayfield for Active Inference Institute at
//https://github.com/docxology/QuadCraft/blob/main/src/js/experiments/QuadrayGrid4.html
//"License This project is licensed under the Apache 2.0 License - see the LICENSE file for details."
</script></body></html>